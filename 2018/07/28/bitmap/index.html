<!DOCTYPE html>
<html lang="z">
<head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    
    <title>如何高效的显示Bitmap | Sunny.SLX的个人博.</title>
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <meta name="description" content="前言了解如何使用常用技术来处理和加载Bitmap，使我们的UI组件保持响应并避免超出应用程序内存限制。如果不小心，Bitmap可以快速消耗你的可用内存预算，导致应用程序崩溃，出现OOM.为什么在Android应用程序中加载Bitmap是件很棘手的事情?&amp;emsp;&amp;emsp; ①移动设备资源受限.Android设备可以为当个应用程序提供少至16MB的内存,所有应当优化应用程序以在最小的内存限制下都">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="如何高效的显示Bitmap | Sunny.SLX的个人博.">
    <meta name="twitter:description" content="前言了解如何使用常用技术来处理和加载Bitmap，使我们的UI组件保持响应并避免超出应用程序内存限制。如果不小心，Bitmap可以快速消耗你的可用内存预算，导致应用程序崩溃，出现OOM.为什么在Android应用程序中加载Bitmap是件很棘手的事情?&amp;emsp;&amp;emsp; ①移动设备资源受限.Android设备可以为当个应用程序提供少至16MB的内存,所有应当优化应用程序以在最小的内存限制下都">

    <meta property="og:type" content="article">
    <meta property="og:title" content="如何高效的显示Bitmap | Sunny.SLX的个人博.">
    <meta property="og:description" content="前言了解如何使用常用技术来处理和加载Bitmap，使我们的UI组件保持响应并避免超出应用程序内存限制。如果不小心，Bitmap可以快速消耗你的可用内存预算，导致应用程序崩溃，出现OOM.为什么在Android应用程序中加载Bitmap是件很棘手的事情?&amp;emsp;&amp;emsp; ①移动设备资源受限.Android设备可以为当个应用程序提供少至16MB的内存,所有应当优化应用程序以在最小的内存限制下都">

    
    <meta name="author" content="Sunny.SLX">
    
    <link rel="stylesheet" href="/css/vno.css">
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css">

    
    <link rel="icon" href="/images/avatar-small.png">
    

    <meta name="generator" content="hexo"/>
    
    <link rel="alternate" type="application/rss+xml" title="Sunny.SLX的个人博." href="/atom.xml">
    

    <link rel="canonical" href="http://yoursite.com/2018/07/28/bitmap/"/>

                 
</head>

<body class="home-template no-js">
    <script src="//cdn.bootcss.com/jquery/2.1.4/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>

    
<header class="panel-cover panel-cover--collapsed" style="background-image: url(/images/background-cover.jpg)">
  <div class="panel-main">
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/" title="前往 Sunny.SLX的个人博. 的主页"><img src="/images/avatar.jpg" width="80" alt="Sunny.SLX的个人博. logo" class="panel-cover__logo logo" /></a>
        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage for Sunny.SLX的个人博.">Sunny.SLX的个人博.</a></h1>
        
        <hr class="panel-cover__divider" />
        <p class="panel-cover__description"></p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />

        <div class="navigation-wrapper">
          <div>
          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">
              <li class="navigation__item"><a href="/#blog" title="Visit the blog" class="blog-button">Blog</a></li>
            
            </ul>
          </nav>
          </div>
          <div>
          <nav class="cover-navigation navigation--social">
  <ul class="navigation">

  <!-- Weibo-->
  

  <!-- Github -->
  
  <li class="navigation__item">
    <a href="https://github.com/sunnyslx" title="GitHub" target="_blank">
      <i class='social fa fa-github'></i>
      <span class="label">Github</span>
    </a>
  </li>


<!-- Stack Overflow -->
        

  <!-- Google Plus -->
  

<!-- Facebook -->

  
<!-- Twitter -->

  <li class="navigation__item">
    <a href="https://twitter.com/onlymonniya" title="Twitter" target="_blank">
      <i class='social fa fa-twitter'></i>
      <span class="label">Twitter</span>
    </a>
  </li>

  

  <li class="navigation__item">
    <a href="/atom.xml" title="RSS" target="_blank">
      <i class='social fa fa-rss'></i>
      <span class="label">RSS</span>
    </a>
  </li>



  </ul>
</nav>

          </div>
        </div>

      </div>

    </div>

    <div class="panel-cover--overlay cover-purple"></div>
  </div> 
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single">

  <header class="post-header">
    <div class="post-meta">
      <time datetime="2018-07-28T10:28:00.028Z" class="post-list__meta--date date">2018-07-28</time> &#8226; <span class="post-meta__tags tags">于  </span>
      <span class="page-pv">
       Read <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span>
      </span> 
   
    </div>
    <h1 class="post-title">如何高效的显示Bitmap</h1>
  </header>

  <section class="post">
    <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>了解如何使用常用技术来处理和加载Bitmap，使我们的UI组件保持响应并避免超出应用程序内存限制。如果不小心，Bitmap可以快速消耗你的可用内存预算，导致应用程序崩溃，出现OOM.<br>为什么在Android应用程序中加载Bitmap是件很棘手的事情?<br>&emsp;&emsp; ①移动设备资源受限.Android设备可以为当个应用程序提供少至16MB的内存,所有应当优化应用程序以在最小的内存限制下都可执行。</p>
<p>&emsp;&emsp; ②Bitmap占用了大量的内存,特别是对于像照片这样的丰富图像,如果使用的位图配置时ARGB_8888(Android系统默认),以1080<em>1920像素的照片为例,则将此图像加载到内存中大约需要8M内存(1080</em>1920*4字节),这样会立即耗尽某些设备上的每个应用程序限制。</p>
<p>&emsp;&emsp; ③Android应用UI通常需要一次就加载几个Bitmap.像ListView,GridView和ViewPager等组件通常就会同时在屏幕上显示几张Bitmap。</p>
<hr>
<h1 id="一-有效的加载大的Bitmap"><a href="#一-有效的加载大的Bitmap" class="headerlink" title="一.有效的加载大的Bitmap"></a>一.有效的加载大的Bitmap</h1><p>不超出每个应用程序内存限制的情况下解码大的Bitmp，方法是在内存中加载较小的Bitmap。</p>
<h2 id="1-1读取Bitmap的尺寸和类型"><a href="#1-1读取Bitmap的尺寸和类型" class="headerlink" title="1.1读取Bitmap的尺寸和类型"></a>1.1读取Bitmap的尺寸和类型</h2><p>BitmapFactory类提供了几种解码方法（decodeByteArray（），decodeFile（），decodeResource（）等），用于从各种源创建Bitmap。 根据图像数据源选择最合适的解码方法。 这些方法尝试为构造的位图分配内存，因此很容易导致OOM异常。 每种类型的解码方法都有其他签名，可通过BitmapFactory.Options类指定解码选项。 解码时将inJustDecodeBounds属性设置为true可避免内存分配，为位图对象返回null，但设置outWidth，outHeight和outMimeType.该方式允许在构造（和内存分配）位图之前读取图像数据的尺寸和类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BitmapFactory.Options options = new BitmapFactory.Options();</span><br><span class="line">options.inJustDecodeBounds = true;</span><br><span class="line">BitmapFactory.decodeResource(getResources(), R.id.myimage, options);</span><br><span class="line">int imageHeight = options.outHeight;</span><br><span class="line">int imageWidth = options.outWidth;</span><br><span class="line">String imageType = options.outMimeType;</span><br></pre></td></tr></table></figure></p>
<p>要避免OOM,就需要在解码之前检查Bitmap的尺寸.</p>
<h2 id="1-2将缩小的Bitmap加载到内存中"><a href="#1-2将缩小的Bitmap加载到内存中" class="headerlink" title="1.2将缩小的Bitmap加载到内存中"></a>1.2将缩小的Bitmap加载到内存中</h2><p>图像尺寸大小已知,它们就可决定是否将完整的图像加载到内存中,或者是够应加载小的Bitmap,以下时需要考虑的因素:<br>&emsp;&emsp; ①估计在内存中加载完整映像的内存使用情况。<br>&emsp;&emsp; ②在给定应用程序的任何其他内存要求的情况下，可以加载此映像的内存量。<br>&emsp;&emsp; ③要加载图像的目标ImageView或UI组件的尺寸。<br>&emsp;&emsp; ④屏幕尺寸和当前设备的密度。<br>要告诉解码器将较小的Bitmap加载到内存中,就需要将BitmapFactory.Options对象中的inSampleSize设置为true。以下是根据目标宽度和高度计算本大小值的方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static int calculateInSampleSize(</span><br><span class="line">            BitmapFactory.Options options, int reqWidth, int reqHeight) &#123;</span><br><span class="line">    //图像的原始高度和宽度</span><br><span class="line">    final int height = options.outHeight;</span><br><span class="line">    final int width = options.outWidth;</span><br><span class="line">    int inSampleSize = 1;</span><br><span class="line">    if (height &gt; reqHeight || width &gt; reqWidth) &#123;</span><br><span class="line">        final int halfHeight = height / 2;</span><br><span class="line">        final int halfWidth = width / 2;</span><br><span class="line">	//计算最大的inSampleSize值，该值为2次幂并保持两者</span><br><span class="line">	//高度和宽度大于要求的高度和宽度。</span><br><span class="line">        while ((halfHeight / inSampleSize) &gt;= reqHeight</span><br><span class="line">                &amp;&amp; (halfWidth / inSampleSize) &gt;= reqWidth) &#123;</span><br><span class="line">            inSampleSize *= 2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return inSampleSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意:计算两个幂的幂是因为解码器使用最终值通过舍入到最接近的2次幂</strong><br>要使用此方法，首先使用inJustDecodeBounds设置为true进行解码，传递选项，然后使用新的inSampleSize值再次解码，并将inJustDecodeBounds设置为false<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static Bitmap decodeSampledBitmapFromResource(Resources res, int resId,</span><br><span class="line">        int reqWidth, int reqHeight) &#123;</span><br><span class="line">    // 首先使用inJustDecodeBounds = true进行解码以检查尺寸</span><br><span class="line">    final BitmapFactory.Options options = new BitmapFactory.Options();</span><br><span class="line">    options.inJustDecodeBounds = true;</span><br><span class="line">    BitmapFactory.decodeResource(res, resId, options);</span><br><span class="line">    // 计算inSampleSize</span><br><span class="line">    options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight);</span><br><span class="line">    // 使用inSampleSize设置解码位图</span><br><span class="line">    options.inJustDecodeBounds = false;</span><br><span class="line">    return BitmapFactory.decodeResource(res, resId, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此方法可以轻松地将任意大尺寸的位图加载到显示100x100像素缩略图的ImageView中，如以下示例代码所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mImageView.setImageBitmap(</span><br><span class="line">    decodeSampledBitmapFromResource(getResources(), R.id.myimage, 100, 100));</span><br></pre></td></tr></table></figure></p>
<h1 id="二-关闭UI线程处理Bitmap"><a href="#二-关闭UI线程处理Bitmap" class="headerlink" title="二.关闭UI线程处理Bitmap"></a>二.关闭UI线程处理Bitmap</h1><p>如果从磁盘或网络位置（或实际上除内存之外的任何其他源）读取源数据，则不应在主UI线程上执行BitmapFactory.decode *方法。 因为这些数据加载所需的时间是不可预测的，取决于各种因素（从磁盘或网络读取的速度，映像的大小，CPU的功率等）。如果其中一个任务阻止了UI线程，系统会将应用程序标记为无响应，并且用户可以选择关闭它。<br>下面主要是讲如何使用AsyncTask处理后台线程中的Bitmap。</p>
<h2 id="2-1-使用AsyncTask"><a href="#2-1-使用AsyncTask" class="headerlink" title="2.1 使用AsyncTask"></a>2.1 使用AsyncTask</h2><p>AsyncTask类提供了一种在后台线程中执行某些工作并将结果发布回UI线程的简单方法。要使用它，就需要创建一个子类并覆盖提供的方法。下面是使用AsyncTask和decodeSampledBitmapFromResource（）将大图像加载到ImageView的示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class BitmapWorkerTask extends AsyncTask&lt;Integer, Void, Bitmap&gt; &#123;</span><br><span class="line">    private final WeakReference&lt;ImageView&gt; imageViewReference;</span><br><span class="line">    private int data = 0;</span><br><span class="line"></span><br><span class="line">    public BitmapWorkerTask(ImageView imageView) &#123;</span><br><span class="line">        // 使用WeakReference确保可以对ImageView进行垃圾回收</span><br><span class="line">        imageViewReference = new WeakReference&lt;ImageView&gt;(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 在后台解码图像。</span><br><span class="line">    @Override</span><br><span class="line">    protected Bitmap doInBackground(Integer... params) &#123;</span><br><span class="line">        data = params[0];</span><br><span class="line">        return decodeSampledBitmapFromResource(getResources(), data, 100, 100));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 完成后，查看ImageView是否仍然存在并设置Bitmap。</span><br><span class="line">    @Override</span><br><span class="line">    protected void onPostExecute(Bitmap bitmap) &#123;</span><br><span class="line">        if (imageViewReference != null &amp;&amp; bitmap != null) &#123;</span><br><span class="line">            final ImageView imageView = imageViewReference.get();</span><br><span class="line">            if (imageView != null) &#123;</span><br><span class="line">                imageView.setImageBitmap(bitmap);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对ImageView的WeakReference确保AsyncTask不会阻止ImageView及其引用的任何内容被垃圾回收。 当任务完成时，无法保证ImageView仍然存在，因此还必须检查onPostExecute（）中的引用。<br>要开始异步加载位图，只需创建一个新任务并执行它：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void loadBitmap(int resId, ImageView imageView) &#123;</span><br><span class="line">    BitmapWorkerTask task = new BitmapWorkerTask(imageView);</span><br><span class="line">    task.execute(resId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-2-处理并发"><a href="#2-2-处理并发" class="headerlink" title="2.2 处理并发"></a>2.2 处理并发</h2><p>当与AsyncTask结合使用时，ListView和GridView等常见视图组件会引入另一个问题，如上一节所示。 为了提高内存的效率，这些组件会在用户滚动时回收子视图。 如果每个子视图都触发AsyncTask，则无法保证在完成时，关联的视图尚未被回收以在另一个子视图中使用。 此外，无法保证异步任务的启动顺序是它们完成的顺序。<br>创建一个专用的Drawable子类，以将引用存储回worker任务。 在这种情况下，使用BitmapDrawable，以便在任务完成时可以在ImageView中显示占位符图像：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static class AsyncDrawable extends BitmapDrawable &#123;</span><br><span class="line">    private final WeakReference&lt;BitmapWorkerTask&gt; bitmapWorkerTaskReference;</span><br><span class="line"></span><br><span class="line">    public AsyncDrawable(Resources res, Bitmap bitmap,</span><br><span class="line">            BitmapWorkerTask bitmapWorkerTask) &#123;</span><br><span class="line">        super(res, bitmap);</span><br><span class="line">        bitmapWorkerTaskReference =</span><br><span class="line">            new WeakReference&lt;BitmapWorkerTask&gt;(bitmapWorkerTask);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BitmapWorkerTask getBitmapWorkerTask() &#123;</span><br><span class="line">        return bitmapWorkerTaskReference.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在执行BitmapWorkerTask之前，需要创建一个AsyncDrawable并将其绑定到目标ImageView：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void loadBitmap(int resId, ImageView imageView) &#123;</span><br><span class="line">    if (cancelPotentialWork(resId, imageView)) &#123;</span><br><span class="line">        final BitmapWorkerTask task = new BitmapWorkerTask(imageView);</span><br><span class="line">        final AsyncDrawable asyncDrawable =</span><br><span class="line">                new AsyncDrawable(getResources(), mPlaceHolderBitmap, task);</span><br><span class="line">        imageView.setImageDrawable(asyncDrawable);</span><br><span class="line">        task.execute(resId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码示例中引用的cancelPotentialWork方法检查另一个正在运行的任务是否已与ImageView关联。 如果是，则尝试通过调用cancel（）取消先前的任务。 在少数情况下，新任务数据与现有任务匹配，不需要进一步发生任何事情。 这是cancelPotentialWork的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static boolean cancelPotentialWork(int data, ImageView imageView) &#123;</span><br><span class="line">    final BitmapWorkerTask bitmapWorkerTask = getBitmapWorkerTask(imageView);</span><br><span class="line"></span><br><span class="line">    if (bitmapWorkerTask != null) &#123;</span><br><span class="line">        final int bitmapData = bitmapWorkerTask.data;</span><br><span class="line">        //如果尚未设置bitmapData或它与新数据不同</span><br><span class="line">        if (bitmapData == 0 || bitmapData != data) &#123;</span><br><span class="line">            // 取消上一个任务</span><br><span class="line">            bitmapWorkerTask.cancel(true);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 同样的工作已在进行中</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 没有与ImageView关联的任务，或者已取消现有任务</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面使用了一个帮助方法getBitmapWorkerTask（）来检索与特定ImageView关联的任务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private static BitmapWorkerTask getBitmapWorkerTask(ImageView imageView) &#123;</span><br><span class="line">   if (imageView != null) &#123;</span><br><span class="line">       final Drawable drawable = imageView.getDrawable();</span><br><span class="line">       if (drawable instanceof AsyncDrawable) &#123;</span><br><span class="line">           final AsyncDrawable asyncDrawable = (AsyncDrawable) drawable;</span><br><span class="line">           return asyncDrawable.getBitmapWorkerTask();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后一步是更新BitmapWorkerTask中的onPostExecute（），以便检查任务是否被取消以及当前任务是否与ImageView相关联的任务匹配：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class BitmapWorkerTask extends AsyncTask&lt;Integer, Void, Bitmap&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onPostExecute(Bitmap bitmap) &#123;</span><br><span class="line">        if (isCancelled()) &#123;</span><br><span class="line">            bitmap = null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (imageViewReference != null &amp;&amp; bitmap != null) &#123;</span><br><span class="line">            final ImageView imageView = imageViewReference.get();</span><br><span class="line">            final BitmapWorkerTask bitmapWorkerTask =</span><br><span class="line">                    getBitmapWorkerTask(imageView);</span><br><span class="line">            if (this == bitmapWorkerTask &amp;&amp; imageView != null) &#123;</span><br><span class="line">                imageView.setImageBitmap(bitmap);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此实现现在适用于ListView和GridView组件以及回收其子视图的任何其他组件。 只需调用loadBitmap，我们通常会将图像设置为ImageView。 例如，在GridView实现中，这将在后备适配器的getView（）方法中。</p>
<h1 id="三-缓存位图"><a href="#三-缓存位图" class="headerlink" title="三.缓存位图"></a>三.缓存位图</h1><p>将单个Bitmap加载到用户界面（UI）非常简单，但是如果需要一次加载更多的图像，事情会变得更加复杂。 在许多情况下（例如使用ListView，GridView或ViewPager等组件），屏幕上的图像总数与可能很快滚动到屏幕上的图像基本上是无限的。<br>通过在子屏幕移动时回收子视图，可以使用这样的组件来降低内存使用率。 垃圾收集器还可以释放加载的Bitmap，假设在没有保留任何长期存在的引用。 这一切都很好，但为了保持流畅和快速加载的UI，我们希望避免每次它们回到屏幕时不断处理这些图像。 内存和磁盘缓存通常可以在这里提供帮助，允许组件快速重新加载已处理的映像。<br>下面将介绍使用内存和磁盘位图缓存来提高加载多个位图时UI的响应能力和流动性。</p>
<h2 id="3-1-使用内存缓存"><a href="#3-1-使用内存缓存" class="headerlink" title="3.1 使用内存缓存"></a>3.1 使用内存缓存</h2><p>内存缓存以占用宝贵的应用程序内存为代价提供对位图的快速访问。 LruCache类（也可在支持库中使用，可用于API级别4）特别适合缓存位图，将最近引用的对象保存在强引用的LinkedHashMap中，并在缓存超过其之前驱逐最近最少使用的成员 指定大小。<br>以下是为Bitmap设置LruCache的示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">private LruCache&lt;String, Bitmap&gt; mMemoryCache;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    ...</span><br><span class="line">    //获取最大可用VM内存，超过此数量将抛出一个OOM异常。 以LruCache为单位存储为千字节</span><br><span class="line">    //在其构造函数中进行定义。</span><br><span class="line">    final int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024);</span><br><span class="line"></span><br><span class="line">    // 使用此内存缓存的1/8可用内存。</span><br><span class="line">    final int cacheSize = maxMemory / 8;</span><br><span class="line"></span><br><span class="line">    mMemoryCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) &#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected int sizeOf(String key, Bitmap bitmap) &#123;</span><br><span class="line">            //缓存大小将以千字节为单位</span><br><span class="line">            return bitmap.getByteCount() / 1024;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void addBitmapToMemoryCache(String key, Bitmap bitmap) &#123;</span><br><span class="line">    if (getBitmapFromMemCache(key) == null) &#123;</span><br><span class="line">        mMemoryCache.put(key, bitmap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Bitmap getBitmapFromMemCache(String key) &#123;</span><br><span class="line">    return mMemoryCache.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将位图加载到ImageView时，首先检查LruCache。 如果找到条目，则立即使用它来更新ImageView，否则会生成后台线程来处理图像：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void loadBitmap(int resId, ImageView imageView) &#123;</span><br><span class="line">    final String imageKey = String.valueOf(resId);</span><br><span class="line"></span><br><span class="line">    final Bitmap bitmap = getBitmapFromMemCache(imageKey);</span><br><span class="line">    if (bitmap != null) &#123;</span><br><span class="line">        mImageView.setImageBitmap(bitmap);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mImageView.setImageResource(R.drawable.image_placeholder);</span><br><span class="line">        BitmapWorkerTask task = new BitmapWorkerTask(mImageView);</span><br><span class="line">        task.execute(resId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>还需要更新BitmapWorkerTask以将条目添加到内存缓存：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class BitmapWorkerTask extends AsyncTask&lt;Integer, Void, Bitmap&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">    // Decode image in background.</span><br><span class="line">    @Override</span><br><span class="line">    protected Bitmap doInBackground(Integer... params) &#123;</span><br><span class="line">        final Bitmap bitmap = decodeSampledBitmapFromResource(</span><br><span class="line">                getResources(), params[0], 100, 100));</span><br><span class="line">        addBitmapToMemoryCache(String.valueOf(params[0]), bitmap);</span><br><span class="line">        return bitmap;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-2-使用磁盘缓存"><a href="#3-2-使用磁盘缓存" class="headerlink" title="3.2 使用磁盘缓存"></a>3.2 使用磁盘缓存</h2><p>内存缓存对于加快对最近查看的位图的访问非常有用，但是不能依赖此缓存中可用的图像。 具有较大数据集的GridView等组件可以轻松填充内存缓存。 应用程序可能会被其他任务（例如电话呼叫）中断，而在后台，它可能会被终止并且内存缓存会被破坏。 用户恢复后，应用程序必须再次处理每个图像。<br>在这些情况下，可以使用磁盘缓存来保留已处理的位图，并有助于减少内存缓存中不再提供映像的加载时间。 当然，从磁盘获取图像比从内存加载要慢，并且应该在后台线程中完成，因为磁盘读取时间可能是不可预测的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">private DiskLruCache mDiskLruCache;</span><br><span class="line">private final Object mDiskCacheLock = new Object();</span><br><span class="line">private boolean mDiskCacheStarting = true;</span><br><span class="line">private static final int DISK_CACHE_SIZE = 1024 * 1024 * 10; // 10MB</span><br><span class="line">private static final String DISK_CACHE_SUBDIR = &quot;thumbnails&quot;;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    ...</span><br><span class="line">    // 初始化内存缓存</span><br><span class="line">    ...</span><br><span class="line">    // 在后台线程上初始化磁盘缓存</span><br><span class="line">    File cacheDir = getDiskCacheDir(this, DISK_CACHE_SUBDIR);</span><br><span class="line">    new InitDiskCacheTask().execute(cacheDir);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class InitDiskCacheTask extends AsyncTask&lt;File, Void, Void&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected Void doInBackground(File... params) &#123;</span><br><span class="line">        synchronized (mDiskCacheLock) &#123;</span><br><span class="line">            File cacheDir = params[0];</span><br><span class="line">            mDiskLruCache = DiskLruCache.open(cacheDir, DISK_CACHE_SIZE);</span><br><span class="line">            mDiskCacheStarting = false; // 完成初始化</span><br><span class="line">            mDiskCacheLock.notifyAll(); // 唤醒所有等待的线程</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BitmapWorkerTask extends AsyncTask&lt;Integer, Void, Bitmap&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">    // 在后台解码图像。</span><br><span class="line">    @Override</span><br><span class="line">    protected Bitmap doInBackground(Integer... params) &#123;</span><br><span class="line">        final String imageKey = String.valueOf(params[0]);</span><br><span class="line"></span><br><span class="line">        // 检查后台线程中的磁盘缓存</span><br><span class="line">        Bitmap bitmap = getBitmapFromDiskCache(imageKey);</span><br><span class="line"></span><br><span class="line">        if (bitmap == null) &#123; // 在磁盘缓存中找不到</span><br><span class="line">            // 正常处理</span><br><span class="line">            final Bitmap bitmap = decodeSampledBitmapFromResource(</span><br><span class="line">                    getResources(), params[0], 100, 100));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 最终Bitmap添加到缓存</span><br><span class="line">        addBitmapToCache(imageKey, bitmap);</span><br><span class="line"></span><br><span class="line">        return bitmap;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void addBitmapToCache(String key, Bitmap bitmap) &#123;</span><br><span class="line">    // 添加到内存缓存</span><br><span class="line">    if (getBitmapFromMemCache(key) == null) &#123;</span><br><span class="line">        mMemoryCache.put(key, bitmap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 添加到磁盘缓存</span><br><span class="line">    synchronized (mDiskCacheLock) &#123;</span><br><span class="line">        if (mDiskLruCache != null &amp;&amp; mDiskLruCache.get(key) == null) &#123;</span><br><span class="line">            mDiskLruCache.put(key, bitmap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Bitmap getBitmapFromDiskCache(String key) &#123;</span><br><span class="line">    synchronized (mDiskCacheLock) &#123;</span><br><span class="line">        // 等待从后台线程启动磁盘缓存</span><br><span class="line">        while (mDiskCacheStarting) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                mDiskCacheLock.wait();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (mDiskLruCache != null) &#123;</span><br><span class="line">            return mDiskLruCache.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建指定应用程序缓存目录的唯一子目录。 试图使用外部,但如果没有安装，则回退到内部存储。</span><br><span class="line">public static File getDiskCacheDir(Context context, String uniqueName) &#123;</span><br><span class="line">检查是否已安装介质或内置存储，如果是，请尝试使用外部缓存目录</span><br><span class="line">  否则使用内部缓存目录</span><br><span class="line">    final String cachePath =</span><br><span class="line">            Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState()) ||</span><br><span class="line">                    !isExternalStorageRemovable() ? getExternalCacheDir(context).getPath() :</span><br><span class="line">                            context.getCacheDir().getPath();</span><br><span class="line"></span><br><span class="line">    return new File(cachePath + File.separator + uniqueName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在UI线程中检查内存高速缓存时，将在后台线程中检查磁盘高速缓存。 磁盘操作绝不应该在UI线程上进行。 图像处理完成后，最终的Bitmap将添加到内存和磁盘缓存中以备将来使用。</p>
<h2 id="3-3-处理配置更改"><a href="#3-3-处理配置更改" class="headerlink" title="3.3 处理配置更改"></a>3.3 处理配置更改</h2><p>运行时配置更改（例如屏幕方向更改）会导致Android使用新配置销毁并重新启动运行活动。 避免再次处理所有图像，以便在发生配置更改时，用户可以获得流畅，快速的体验。<br>不过可以使用通过调用setRetainInstance（true）保留的Fragment将此高速缓存传递给新的Activity实例。 重新创建Activity后，将重新附加此保留的Fragment，可以访问现有的缓存对象，从而可以快速获取图像并将其重新填充到ImageView对象中。<br>下面介绍在配置更改中保留LruCache对象的示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private LruCache&lt;String, Bitmap&gt; mMemoryCache;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    ...</span><br><span class="line">    RetainFragment retainFragment =</span><br><span class="line">            RetainFragment.findOrCreateRetainFragment(getFragmentManager());</span><br><span class="line">    mMemoryCache = retainFragment.mRetainedCache;</span><br><span class="line">    if (mMemoryCache == null) &#123;</span><br><span class="line">        mMemoryCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) &#123;</span><br><span class="line">            ... // 初始化缓存</span><br><span class="line">        &#125;</span><br><span class="line">        retainFragment.mRetainedCache = mMemoryCache;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class RetainFragment extends Fragment &#123;</span><br><span class="line">    private static final String TAG = &quot;RetainFragment&quot;;</span><br><span class="line">    public LruCache&lt;String, Bitmap&gt; mRetainedCache;</span><br><span class="line"></span><br><span class="line">    public RetainFragment() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static RetainFragment findOrCreateRetainFragment(FragmentManager fm) &#123;</span><br><span class="line">        RetainFragment fragment = (RetainFragment) fm.findFragmentByTag(TAG);</span><br><span class="line">        if (fragment == null) &#123;</span><br><span class="line">            fragment = new RetainFragment();</span><br><span class="line">            fm.beginTransaction().add(fragment, TAG).commit();</span><br><span class="line">        &#125;</span><br><span class="line">        return fragment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setRetainInstance(true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="四-管理Bitmap内存"><a href="#四-管理Bitmap内存" class="headerlink" title="四.管理Bitmap内存"></a>四.管理Bitmap内存</h1><p>除了缓存位图中描述的步骤之外，还可以执行一些特定操作来促进垃圾收集和位图重用。</p>
<h2 id="4-1-在Android-3-0及更高版本上管理内存"><a href="#4-1-在Android-3-0及更高版本上管理内存" class="headerlink" title="4.1 在Android 3.0及更高版本上管理内存"></a>4.1 在Android 3.0及更高版本上管理内存</h2><h3 id="4-1-1-保存Bitmap供以后使用"><a href="#4-1-1-保存Bitmap供以后使用" class="headerlink" title="4.1.1 保存Bitmap供以后使用"></a>4.1.1 保存Bitmap供以后使用</h3><p>以下代码段演示了如何存储现有位图，以便以后在示例应用程序中使用。 当应用程序在Android 3.0或更高版本上运行并且位图从LruCache中逐出时，对位图的软引用将放置在HashSet中，以便稍后可以在inBitmap中重用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;SoftReference&lt;Bitmap&gt;&gt; mReusableBitmaps;</span><br><span class="line">private LruCache&lt;String, BitmapDrawable&gt; mMemoryCache;</span><br><span class="line"></span><br><span class="line">//如果在Honeycomb或更新版本上运行，请创建一个synchronized HashSet对可重用位图的引用。</span><br><span class="line">if (Utils.hasHoneycomb()) &#123;</span><br><span class="line">    mReusableBitmaps =</span><br><span class="line">            Collections.synchronizedSet(new HashSet&lt;SoftReference&lt;Bitmap&gt;&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mMemoryCache = new LruCache&lt;String, BitmapDrawable&gt;(mCacheParams.memCacheSize) &#123;</span><br><span class="line"></span><br><span class="line">    // 通知已删除的不再缓存的条目。</span><br><span class="line">    @Override</span><br><span class="line">    protected void entryRemoved(boolean evicted, String key,</span><br><span class="line">            BitmapDrawable oldValue, BitmapDrawable newValue) &#123;</span><br><span class="line">        if (RecyclingBitmapDrawable.class.isInstance(oldValue)) &#123;</span><br><span class="line">           //删除的条目是回收可绘制的，因此需要通知它已从内存缓存中删除。</span><br><span class="line">            ((RecyclingBitmapDrawable) oldValue).setIsCached(false);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 删除的条目是标准的BitmapDrawable。</span><br><span class="line">            if (Utils.hasHoneycomb()) &#123;</span><br><span class="line">                //我们在Honeycomb或更高版本上运行，因此添加位图到一个SoftReference</span><br><span class="line">		//集合，以便以后可能与inBitmap一起使用。</span><br><span class="line">                mReusableBitmaps.add</span><br><span class="line">                        (new SoftReference&lt;Bitmap&gt;(oldValue.getBitmap()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="4-1-2-使用现有Bitmap"><a href="#4-1-2-使用现有Bitmap" class="headerlink" title="4.1.2 使用现有Bitmap"></a>4.1.2 使用现有Bitmap</h3><p>在运行的应用程序中，解码器方法检查是否存在可以使用的现有Bitmap。 例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static Bitmap decodeSampledBitmapFromFile(String filename,</span><br><span class="line">        int reqWidth, int reqHeight, ImageCache cache) &#123;</span><br><span class="line"></span><br><span class="line">    final BitmapFactory.Options options = new BitmapFactory.Options();</span><br><span class="line">    ...</span><br><span class="line">    BitmapFactory.decodeFile(filename, options);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    // If we&apos;re running on Honeycomb or newer, try to use inBitmap.</span><br><span class="line">    if (Utils.hasHoneycomb()) &#123;</span><br><span class="line">        addInBitmapOptions(options, cache);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    return BitmapFactory.decodeFile(filename, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面代码显示了上述代码段中调用的addInBitmapOptions（）方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">private static void addInBitmapOptions(BitmapFactory.Options options,</span><br><span class="line">        ImageCache cache) &#123;</span><br><span class="line">   //inBitmap只适用于可变位图，因此强制解码器返回可变位图。</span><br><span class="line">    options.inMutable = true;</span><br><span class="line">    if (cache != null) &#123;</span><br><span class="line">        // 尝试找到用于inBitmap的位图。</span><br><span class="line">        Bitmap inBitmap = cache.getBitmapFromReusableSet(options);</span><br><span class="line"></span><br><span class="line">        if (inBitmap != null) &#123;</span><br><span class="line">            //如果找到合适的位图，请将其设置为值inBitmap。</span><br><span class="line">            options.inBitmap = inBitmap;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//此方法遍历可重用的位图，查找一个用于inBitmap：</span><br><span class="line">protected Bitmap getBitmapFromReusableSet(BitmapFactory.Options options) &#123;</span><br><span class="line">        Bitmap bitmap = null;</span><br><span class="line"></span><br><span class="line">    if (mReusableBitmaps != null &amp;&amp; !mReusableBitmaps.isEmpty()) &#123;</span><br><span class="line">        synchronized (mReusableBitmaps) &#123;</span><br><span class="line">            final Iterator&lt;SoftReference&lt;Bitmap&gt;&gt; iterator</span><br><span class="line">                    = mReusableBitmaps.iterator();</span><br><span class="line">            Bitmap item;</span><br><span class="line"></span><br><span class="line">            while (iterator.hasNext()) &#123;</span><br><span class="line">                item = iterator.next().get();</span><br><span class="line"></span><br><span class="line">                if (null != item &amp;&amp; item.isMutable()) &#123;</span><br><span class="line">                    // 检查以查看该项目可用于inBitmap。</span><br><span class="line">                    if (canUseForInBitmap(item, options)) &#123;</span><br><span class="line">                        bitmap = item;</span><br><span class="line"></span><br><span class="line">                        // 从可重复使用的设备中取出，因此无法再次使用。</span><br><span class="line">                        iterator.remove();</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 如果已清除引用，则从集合中删除。</span><br><span class="line">                    iterator.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return bitmap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后，此方法确定候选位图是否满足用于inBitmap的大小标准：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">static boolean canUseForInBitmap(</span><br><span class="line">        Bitmap candidate, BitmapFactory.Options targetOptions) &#123;</span><br><span class="line"></span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">        //从Android 4.4开始，我们可以重新使用新Bitmap小于可重复使用的</span><br><span class="line">	//Bitmap候选分配字节数。</span><br><span class="line">        int width = targetOptions.outWidth / targetOptions.inSampleSize;</span><br><span class="line">        int height = targetOptions.outHeight / targetOptions.inSampleSize;</span><br><span class="line">        int byteCount = width * height * getBytesPerPixel(candidate.getConfig());</span><br><span class="line">        return byteCount &lt;= candidate.getAllocationByteCount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 在早期版本中，维度必须完全匹配，并且inSampleSize必须为1</span><br><span class="line">    return candidate.getWidth() == targetOptions.outWidth</span><br><span class="line">            &amp;&amp; candidate.getHeight() == targetOptions.outHeight</span><br><span class="line">            &amp;&amp; targetOptions.inSampleSize == 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *一个辅助函数，用于根据位图的配置返回位图的每个像素的字节使用情况。</span><br><span class="line"> */</span><br><span class="line">static int getBytesPerPixel(Config config) &#123;</span><br><span class="line">    if (config == Config.ARGB_8888) &#123;</span><br><span class="line">        return 4;</span><br><span class="line">    &#125; else if (config == Config.RGB_565) &#123;</span><br><span class="line">        return 2;</span><br><span class="line">    &#125; else if (config == Config.ARGB_4444) &#123;</span><br><span class="line">        return 2;</span><br><span class="line">    &#125; else if (config == Config.ALPHA_8) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="五-在UI中显示Bitmap"><a href="#五-在UI中显示Bitmap" class="headerlink" title="五 在UI中显示Bitmap"></a>五 在UI中显示Bitmap</h1><p>下面将展示如何使用后台线程和位图缓存将多个位图加载到ViewPager和GridView组件中，同时处理并发和配置更改。</p>
<h2 id="5-1-将位图加载到ViewPager实现中"><a href="#5-1-将位图加载到ViewPager实现中" class="headerlink" title="5.1 将位图加载到ViewPager实现中"></a>5.1 将位图加载到ViewPager实现中</h2><p>滑动视图图案是导航图库的详细视图的绝佳方式。 可以使用由PagerAdapter支持的ViewPager组件来实现此模式。 但是，更合适的后备适配器是子类FragmentStatePagerAdapter，它会在ViewPager中自动销毁和保存片段的状态，因为它们会在屏幕外消失，从而降低内存使用率。<br>以下使用ImageView子级的ViewPager的实现。 主要活动包含ViewPager和适配器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class ImageDetailActivity extends FragmentActivity &#123;</span><br><span class="line">    public static final String EXTRA_IMAGE = &quot;extra_image&quot;;</span><br><span class="line"></span><br><span class="line">    private ImagePagerAdapter mAdapter;</span><br><span class="line">    private ViewPager mPager;</span><br><span class="line"></span><br><span class="line">    // 用于支持ViewPager适配器的静态数据集</span><br><span class="line">    public final static Integer[] imageResIds = new Integer[] &#123;</span><br><span class="line">            R.drawable.sample_image_1, R.drawable.sample_image_2, R.drawable.sample_image_3,</span><br><span class="line">            R.drawable.sample_image_4, R.drawable.sample_image_5, R.drawable.sample_image_6,</span><br><span class="line">            R.drawable.sample_image_7, R.drawable.sample_image_8, R.drawable.sample_image_9&#125;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.image_detail_pager); // 仅包含ViewPager</span><br><span class="line"></span><br><span class="line">        mAdapter = new ImagePagerAdapter(getSupportFragmentManager(), imageResIds.length);</span><br><span class="line">        mPager = (ViewPager) findViewById(R.id.pager);</span><br><span class="line">        mPager.setAdapter(mAdapter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class ImagePagerAdapter extends FragmentStatePagerAdapter &#123;</span><br><span class="line">        private final int mSize;</span><br><span class="line"></span><br><span class="line">        public ImagePagerAdapter(FragmentManager fm, int size) &#123;</span><br><span class="line">            super(fm);</span><br><span class="line">            mSize = size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public int getCount() &#123;</span><br><span class="line">            return mSize;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public Fragment getItem(int position) &#123;</span><br><span class="line">            return ImageDetailFragment.newInstance(position);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是一个包含ImageView子元素的细节Fragment的实现,怎么可以改进？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class ImageDetailFragment extends Fragment &#123;</span><br><span class="line">    private static final String IMAGE_DATA_EXTRA = &quot;resId&quot;;</span><br><span class="line">    private int mImageNum;</span><br><span class="line">    private ImageView mImageView;</span><br><span class="line"></span><br><span class="line">    static ImageDetailFragment newInstance(int imageNum) &#123;</span><br><span class="line">        final ImageDetailFragment f = new ImageDetailFragment();</span><br><span class="line">        final Bundle args = new Bundle();</span><br><span class="line">        args.putInt(IMAGE_DATA_EXTRA, imageNum);</span><br><span class="line">        f.setArguments(args);</span><br><span class="line">        return f;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 空构造函数，根据Fragment docs所需</span><br><span class="line">    public ImageDetailFragment() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        mImageNum = getArguments() != null ? getArguments().getInt(IMAGE_DATA_EXTRA) : -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public View onCreateView(LayoutInflater inflater, ViewGroup container,</span><br><span class="line">            Bundle savedInstanceState) &#123;</span><br><span class="line">        // image_detail_fragment.xml 只包含一个 ImageView</span><br><span class="line">        final View v = inflater.inflate(R.layout.image_detail_fragment, container, false);</span><br><span class="line">        mImageView = (ImageView) v.findViewById(R.id.imageView);</span><br><span class="line">        return v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onActivityCreated(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onActivityCreated(savedInstanceState);</span><br><span class="line">        final int resId = ImageDetailActivity.imageResIds[mImageNum];</span><br><span class="line">        mImageView.setImageResource(resId); // 将图像加载到ImageView中</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上会有一个问题：从UI线程上的资源中读取图像，这可能导致应用程序挂起并被强制关闭。 使用处理位图关闭UI线程课程中描述的AsyncTask，可以直接将图像加载和处理移动到后台线程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class ImageDetailActivity extends FragmentActivity &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    public void loadBitmap(int resId, ImageView imageView) &#123;</span><br><span class="line">        mImageView.setImageResource(R.drawable.image_placeholder);</span><br><span class="line">        BitmapWorkerTask task = new BitmapWorkerTask(mImageView);</span><br><span class="line">        task.execute(resId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... // 包括BitmapWorkerTask类</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ImageDetailFragment extends Fragment &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onActivityCreated(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onActivityCreated(savedInstanceState);</span><br><span class="line">        if (ImageDetailActivity.class.isInstance(getActivity())) &#123;</span><br><span class="line">            final int resId = ImageDetailActivity.imageResIds[mImageNum];</span><br><span class="line">            // 调用ImageDetailActivity以在后台线程中加载Bitmap</span><br><span class="line">            ((ImageDetailActivity) getActivity()).loadBitmap(resId, mImageView);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>任何其他处理（例如调整大小或从网络获取图像）都可以在BitmapWorkerTask中进行，而不会影响主UI的响应性。 如果后台线程不仅仅是直接从磁盘加载映像，那么添加内存和/或磁盘缓存也是有益的， 以下是内存缓存的其他修改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class ImageDetailActivity extends FragmentActivity &#123;</span><br><span class="line">    ...</span><br><span class="line">    private LruCache&lt;String, Bitmap&gt; mMemoryCache;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        ...</span><br><span class="line">        // 根据“使用内存缓存”部分初始化LruCache</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void loadBitmap(int resId, ImageView imageView) &#123;</span><br><span class="line">        final String imageKey = String.valueOf(resId);</span><br><span class="line"></span><br><span class="line">        final Bitmap bitmap = mMemoryCache.get(imageKey);</span><br><span class="line">        if (bitmap != null) &#123;</span><br><span class="line">            mImageView.setImageBitmap(bitmap);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mImageView.setImageResource(R.drawable.image_placeholder);</span><br><span class="line">            BitmapWorkerTask task = new BitmapWorkerTask(mImageView);</span><br><span class="line">            task.execute(resId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... // 包括使用内存缓存部分更新的BitmapWorkerTask</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将所有这些部分放在一起可以为您提供响应式ViewPager实现，同时将图像加载延迟降至最低，并且能够根据需要对图像进行尽可能多的背景处理。</p>
<h2 id="5-2-将Bitmap加载到GridView中"><a href="#5-2-将Bitmap加载到GridView中" class="headerlink" title="5.2 将Bitmap加载到GridView中"></a>5.2 将Bitmap加载到GridView中</h2><p>网格列表构建块对于显示图像数据集很有用，并且可以使用GridView组件实现，其中许多图像可以在任何时间在屏幕上显示，并且如果用户向上或向下滚动，还需要准备好更多图像。 实现此类控件时，必须确保UI保持流畅，内存使用仍然受到控制，并且正确处理并发（由于GridView回收其子视图的方式）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">public class ImageGridFragment extends Fragment implements AdapterView.OnItemClickListener &#123;</span><br><span class="line">    private ImageAdapter mAdapter;</span><br><span class="line"></span><br><span class="line">    //用于支持GridView适配器的静态数据集</span><br><span class="line">    public final static Integer[] imageResIds = new Integer[] &#123;</span><br><span class="line">            R.drawable.sample_image_1, R.drawable.sample_image_2, R.drawable.sample_image_3,</span><br><span class="line">            R.drawable.sample_image_4, R.drawable.sample_image_5, R.drawable.sample_image_6,</span><br><span class="line">            R.drawable.sample_image_7, R.drawable.sample_image_8, R.drawable.sample_image_9&#125;;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    public ImageGridFragment() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        mAdapter = new ImageAdapter(getActivity());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public View onCreateView(</span><br><span class="line">            LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123;</span><br><span class="line">        final View v = inflater.inflate(R.layout.image_grid_fragment, container, false);</span><br><span class="line">        final GridView mGridView = (GridView) v.findViewById(R.id.gridView);</span><br><span class="line">        mGridView.setAdapter(mAdapter);</span><br><span class="line">        mGridView.setOnItemClickListener(this);</span><br><span class="line">        return v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onItemClick(AdapterView&lt;?&gt; parent, View v, int position, long id) &#123;</span><br><span class="line">        final Intent i = new Intent(getActivity(), ImageDetailActivity.class);</span><br><span class="line">        i.putExtra(ImageDetailActivity.EXTRA_IMAGE, position);</span><br><span class="line">        startActivity(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private class ImageAdapter extends BaseAdapter &#123;</span><br><span class="line">        private final Context mContext;</span><br><span class="line"></span><br><span class="line">        public ImageAdapter(Context context) &#123;</span><br><span class="line">            super();</span><br><span class="line">            mContext = context;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public int getCount() &#123;</span><br><span class="line">            return imageResIds.length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public Object getItem(int position) &#123;</span><br><span class="line">            return imageResIds[position];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public long getItemId(int position) &#123;</span><br><span class="line">            return position;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public View getView(int position, View convertView, ViewGroup container) &#123;</span><br><span class="line">            ImageView imageView;</span><br><span class="line">            if (convertView == null) &#123; // 如果它没有被回收，则初始化一些属性</span><br><span class="line">                imageView = new ImageView(mContext);</span><br><span class="line">                imageView.setScaleType(ImageView.ScaleType.CENTER_CROP);</span><br><span class="line">                imageView.setLayoutParams(new GridView.LayoutParams(</span><br><span class="line">                        LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                imageView = (ImageView) convertView;</span><br><span class="line">            &#125;</span><br><span class="line">            imageView.setImageResource(imageResIds[position]); </span><br><span class="line">            return imageView;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再一次，这个实现的问题是图像是在UI线程中设置的。 虽然这可能适用于小而简单的图像（由于系统资源加载和缓存），但如果需要进行任何其他处理，UI将停止运行。<br>可以在此处实现前一节中的相同异步处理和缓存方法,这是解决方案：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public class ImageGridFragment extends Fragment implements AdapterView.OnItemClickListener &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    private class ImageAdapter extends BaseAdapter &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public View getView(int position, View convertView, ViewGroup container) &#123;</span><br><span class="line">            ...</span><br><span class="line">            loadBitmap(imageResIds[position], imageView)</span><br><span class="line">            return imageView;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void loadBitmap(int resId, ImageView imageView) &#123;</span><br><span class="line">        if (cancelPotentialWork(resId, imageView)) &#123;</span><br><span class="line">            final BitmapWorkerTask task = new BitmapWorkerTask(imageView);</span><br><span class="line">            final AsyncDrawable asyncDrawable =</span><br><span class="line">                    new AsyncDrawable(getResources(), mPlaceHolderBitmap, task);</span><br><span class="line">            imageView.setImageDrawable(asyncDrawable);</span><br><span class="line">            task.execute(resId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class AsyncDrawable extends BitmapDrawable &#123;</span><br><span class="line">        private final WeakReference&lt;BitmapWorkerTask&gt; bitmapWorkerTaskReference;</span><br><span class="line"></span><br><span class="line">        public AsyncDrawable(Resources res, Bitmap bitmap,</span><br><span class="line">                BitmapWorkerTask bitmapWorkerTask) &#123;</span><br><span class="line">            super(res, bitmap);</span><br><span class="line">            bitmapWorkerTaskReference =</span><br><span class="line">                new WeakReference&lt;BitmapWorkerTask&gt;(bitmapWorkerTask);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public BitmapWorkerTask getBitmapWorkerTask() &#123;</span><br><span class="line">            return bitmapWorkerTaskReference.get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static boolean cancelPotentialWork(int data, ImageView imageView) &#123;</span><br><span class="line">        final BitmapWorkerTask bitmapWorkerTask = getBitmapWorkerTask(imageView);</span><br><span class="line"></span><br><span class="line">        if (bitmapWorkerTask != null) &#123;</span><br><span class="line">            final int bitmapData = bitmapWorkerTask.data;</span><br><span class="line">            if (bitmapData != data) &#123;</span><br><span class="line">                // 取消上一个任务</span><br><span class="line">                bitmapWorkerTask.cancel(true);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 同样的工作已在进行中</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 没有与ImageView关联的任务，或者已取消现有任务</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static BitmapWorkerTask getBitmapWorkerTask(ImageView imageView) &#123;</span><br><span class="line">       if (imageView != null) &#123;</span><br><span class="line">           final Drawable drawable = imageView.getDrawable();</span><br><span class="line">           if (drawable instanceof AsyncDrawable) &#123;</span><br><span class="line">               final AsyncDrawable asyncDrawable = (AsyncDrawable) drawable;</span><br><span class="line">               return asyncDrawable.getBitmapWorkerTask();</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意：同样的代码也可以很容易地适用于ListView。</strong></p>

  </section>

</article>

<section class="read-more">
           
    
               
            <div class="read-more-item">
                <span class="read-more-item-dim">Newer Post</span>
                <h2 class="post-list__post-title post-title"><a href="/2018/07/30/environment/" title="如何在ubuntu搭建Android开发环境">如何在ubuntu搭建Android开发环境</a></h2>
                <p class="excerpt">
                
                要进行程序的开发前提是:搭建开发环境下面我就介绍一下如何搭建Android开发环境.
一 安装jdkAndroid开发使用的语言是java,既然要使用java这就要牵扯到jdk了.步骤:1.1 下载jdk.官网地址:http://www.oracle.com/technetwork/java/jav
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2018-07-30T10:34:57.446Z" class="post-list__meta--date date">2018-07-30</time> &#8226; <span class="post-list__meta--tags tags">于 </span><a class="btn-border-small" href="/2018/07/30/environment/">继续阅读</a></div>
                           
            </div>
        
        
               
            <div class="read-more-item">
                <span class="read-more-item-dim">Older Post</span>
                <h2 class="post-list__post-title post-title"><a href="/2018/07/26/opengl-trangle/" title="初识OpenGL ES2.0">初识OpenGL ES2.0</a></h2>
                <p class="excerpt">
                
                概述要在Android应用中使用OpenGL ES绘制图形就必须为它们创建一个视图容器,使用该容器这边就需要引入GLSurfaceView和GLSurfaceView.Renderer.GLSurfaceView是使用OpenGL和GLSurfaceView.Renderer绘制的图形的视图容器,用
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2018-07-26T10:13:24.604Z" class="post-list__meta--date date">2018-07-26</time> &#8226; <span class="post-list__meta--tags tags">于 </span><a class="btn-border-small" href="/2018/07/26/opengl-trangle/">继续阅读</a></div>
                       
            </div>
        
     
   
   
  
</section>

  

            <footer class="footer">
    <span class="footer__copyright">
        &copy; 2018 Sunny.SLX - 本站点采用 <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>
       
    </span>
    <span class="footer__copyright">
             - 基于 <a href="http://hexo.io">Hexo</a> 搭建，使用 <a href="https://github.com/monniya/hexo-theme-new-vno ">new-vno</a> 主题，由<a href="https://monniya.com ">@Monniya</a> 修改自 <a href="https://github.com/lenbo-ma/hexo-theme-vno" target="_blank">Vno</a>, 原创出自<a href="http://github.com/onevcat/vno" target="_blank">onevcat</a>
         </span>
       
    
    
</footer>


        </div>
    </div>

     
<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	ga('create', 'UA-78918255-1', 'auto');
	ga('send', 'pageview');
</script>

    
    <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?9cdad07c755fa23f6aced510c6760e87";
            var s = document.getElementsByTagName("script")[0]; 
            s.parentNode.insertBefore(hm, s);
        })();
    </script>



    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    
</body>
</html>
