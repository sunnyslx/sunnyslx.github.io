{"meta":{"title":"Sunny.SLX的个人博.","subtitle":null,"description":null,"author":"Sunny.SLX","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"网络数据传输协议","slug":"TCp-Udp","date":"2018-11-24T07:35:21.000Z","updated":"2018-11-24T07:37:26.139Z","comments":true,"path":"2018/11/24/TCp-Udp/","link":"","permalink":"http://yoursite.com/2018/11/24/TCp-Udp/","excerpt":"","text":"一、TCP协议TCP协议是面向连接、可靠的数据传输协议数据从应用层发下来，会在每一层加上头部信息进行封装，然后发送数据接收端，所有数据的发送和接收其实是数据的封装和解封装的过程。由于TCP是可靠的传输，无论哪一方向另一方发送数据之前，都必须在双方之间建立一个三次握手的协议，断开连接就必须建立四次挥手的协议。 1.1 TCP的三次握手协议在Tcp/Ip协议中，TCP提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号，并交换TCP窗口大小信息。下图为TCP的通信过程： 1.1.1 三次握手具体过程① 第一次握手客户端向服务器发送连接请求报文，然后客户端处于进入SYN_SEND状态，等待服务器的确认。（客户端的建立连接并等待确认）② 第二次握手服务器收到SYN报文，并对这个SYN报文段进行确认，同时发送SYN请求信息，服务器端将上述所有信息放到一个报文段(即SYN+ACK报文段)中，一并将信息发送客户端，然后服务器进入SYN_RECV状态。（服务器端发送相关报文段信息并等待连接）③ 第三次握手客户端收到SYN+ACK报文段，向服务器发送ACK报文段，当报文发送完毕就完成了Tcp三次握手协议。（客户端接收到服务器端信息并实现连接） 1.1.2 四次挥手具体过程① 第一次挥手客户端向服务器端发送一个FIN报文段，服务器端进入FIN_WAIT状态，表示已经没有数据向服务器端发送了。② 第二次挥手服务器端收到客户端发送过来的FIN报文，向客户端回一个ACK报文，服务器端进入CLOSE_WAIT状态，并告诉客户端它也没有数据发送了。③ 第三次挥手服务器端向客户端发送FIN报文，请求关闭连接。④ 第四次挥手客户端接收到服务器端的FIN报文，并向服务器端回一个ACK报文，关闭连接。由于TCP保证了数据传输的可靠性，所以对性能消耗也会变大，数据传输的效率也会变低。 ##二、UDP协议和TCP一样，UDP也属于传输层协议，其主要作用是将网络数据流量压缩成数据包的形式，内容组成为报文头+具体传输的数据。 2.1 UDP特征① UDP是无连接传输协议；② 由于传输数据不需要建立连接，因此也就不需要维护连接状态，包括收发状态；③ UDP信息包的标题很短，只有8个字节，相对于TCP的20个字节信息包的额外开销很小；④ 吞吐量不受拥挤控制算法的调节，只受应用软件生成数据的速率、传输带宽、源端和终端主机性能的限制；⑤ UDP尽最大努力交付，但不保证可靠交付；⑥ UDP是面向报文的。总结以下：UDP连接具有资源消耗少，处理速度的优点，使用通常音频、视频、普通数据使用UDP传输数据较多。 ##三、TCP和UDP的区别① TCP是面向连接的，保证传输数据的可靠安全，而UDP是非面向连接的，不可靠但高效率；② TCP占用资源多，而UDP占用资源少；③ TCP是流模式（通信双方是互相、明确的），而UDP是报文模式；④ 应用场景不同。 ##四、TCP的粘包和UDP的丢包 4.1 TCP的粘包TCP的粘包现象是指：发送方发送的若干数据包到接收方接收时粘成一包，从接收缓冲区来看就是，后一包数据的头紧接着前一包数据的尾。TCP粘包处理方法应用程序在处理从缓存读取的分组时，读完一条数据就紧接着读取下一条数据，直到所有的数据都被处理。 4.2 UDP的丢包UDP丢包现象是指由于UDP是不可靠连接，受到各种因素影响，数据包可能会在接收过程中丢失一部分，从而导致数据的不完整。","categories":[],"tags":[]},{"title":"Android Handler消息处理机制","slug":"handler","date":"2018-11-15T07:50:38.765Z","updated":"2018-11-15T07:50:38.685Z","comments":true,"path":"2018/11/15/handler/","link":"","permalink":"http://yoursite.com/2018/11/15/handler/","excerpt":"","text":"我们知道activity的异常响应事件为5秒,也就是说.超过该时间就会报ANR(Application Not Response)异常,所以耗时操作就不能在主线程中进行，需要放入到子线程中。而当异步处理成功后需要更新视图,但子线程中不能更新UI,所以这个时候就需要借助handler来处理。即handler在新线程中发送消息,在主线程中接收并处理消息。123456789101112131415161718192021222324252627@Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); new Thread(new Runnable() &#123; @Override public void run() &#123; //发送消息 Message message=Message.obtain(); message.what=0x001; myHandler.sendMessage(message); &#125; &#125;).start(); &#125; @SuppressLint(&quot;HandlerLeak&quot;) private Handler myHandler =new Handler()&#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); //接受消息,并处理消息 switch (msg.what)&#123; case 0x001: break; &#125; &#125; &#125;; 一、Handler1.1 Handler作用①在新线程中发送消息②在主线程中获取和处理消息 1.2 Handler中用来发送和处理消息的方法★ void handleMessage（Message msg）：处理消息的方法。通常用于被重写。★ final boolean hasMessages（int what）:检查消息队列中是否包含what属性指定值的消息。★ final boolean hasMessages（int what，Object object）:检查消息队列中是否包含what属性为指定值且object属性为指定消息对象的消息。★ 多个重载的Message obtainMessage（）：获取消息。★ sendEmptyMessage（int what）:发送空消息。★ final boolean sendEmptyMessageDelayed（int what，long delayMillis）：指定多少毫秒后发送空消息。★ final boolean sendMessage（Message msg）：立即发送消息。★final boolean sendMessageDelayed（Message msg，long delayMillis）：指定多少毫秒后发送消息。 1.3 handler发送消息流程程序使用handler发送消息，而handler发送的消息被送到了指定的MessageQueue中。而MessageQueue被Looper管理，Looper循环的去读取MessageQueue中的Message,并把消息分发给对应的handler进行处理。 二、MessageQueue消息队列，采用先进先出的方式去管理Message。在程序创建Looper对象时，会在它的构造中创建MessageQueue对象1234private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread();&#125; MessageQueue中有两个重要的方法，一个是 enqueueMessage(Message msg, long when)即入队方法，next()即出队。 三、Looper通过查看Looper源码我们知道在Looper的构造中创建了MessageQueue，而Looper又是怎么被创建的呢？ 3.1 Looper创建方法3.1.1 UI线程在主线程中，系统已经初始化了一个Looper对象，所有程序只需要创建Handler对象即可，然后就可以通过Handler发送消息，处理消息。 3.1.2 子线程子线程中必须自己创建一个Looper对象，方法为：Looper.prepare()。123456private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125; 3.2 Looper中的loop()方法loop()方法使用一个死循环不断的去读取MessageQueue中的消息，并将取出消息发送给该消息对应的handler去处理。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; // This must be in a local variable, in case a UI event sets the logger final Printer logging = me.mLogging; if (logging != null) &#123; logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; + msg.callback + &quot;: &quot; + msg.what); &#125; final long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs; final long traceTag = me.mTraceTag; if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123; Trace.traceBegin(traceTag, msg.target.getTraceName(msg)); &#125; final long start = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis(); final long end; try &#123; msg.target.dispatchMessage(msg); end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis(); &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; if (slowDispatchThresholdMs &gt; 0) &#123; final long time = end - start; if (time &gt; slowDispatchThresholdMs) &#123; Slog.w(TAG, &quot;Dispatch took &quot; + time + &quot;ms on &quot; + Thread.currentThread().getName() + &quot;, h=&quot; + msg.target + &quot; cb=&quot; + msg.callback + &quot; msg=&quot; + msg.what); &#125; &#125; if (logging != null) &#123; logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback); &#125; // Make sure that during the course of dispatching the // identity of the thread wasn&apos;t corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; Log.wtf(TAG, &quot;Thread identity changed from 0x&quot; + Long.toHexString(ident) + &quot; to 0x&quot; + Long.toHexString(newIdent) + &quot; while dispatching to &quot; + msg.target.getClass().getName() + &quot; &quot; + msg.callback + &quot; what=&quot; + msg.what); &#125; msg.recycleUnchecked();&#125; loop()方法是一个死循环，唯一跳出的循环的方式是MessageQueue的next方法返回null，当Looper退出后，Handler就无法发送消息，send出去的消息会返回false；当我们在子线程中创建了Looper并且所有的消息都处理完毕的时候，要记得调用 quit 方法，不让这个Looper就一直处于阻塞状态一直那么等待下去。 四、总结★ Looper：每一个线程只有一个Looper，它负责管理MessageQueues，不断的从MessageQueue中读取消息，在把读取到的消息发送给对应的Handler处理。★ MessageQueue：由Looper管理，采用先进先出的方式管理Message。★ Handler：把消息发送给Looper管理的MessageQueue，并负责处理Looper分发给它的消息。","categories":[],"tags":[]},{"title":"使用CoordinatorLayout打造酷炫效果","slug":"coordinatelayout","date":"2018-10-22T07:28:48.000Z","updated":"2018-11-24T07:37:37.623Z","comments":true,"path":"2018/10/22/coordinatelayout/","link":"","permalink":"http://yoursite.com/2018/10/22/coordinatelayout/","excerpt":"","text":"#CoordinateLayout打造酷炫效果 一、CoordinatorLayout简介CoordinatorLayout是Android5.0之后推出的一个功能,它与AppBarLayout结合可以打造非常酷炫的效果.一般将CoordinatorLayout布局分为两部分,上半部分是AppBarLayout包裹的内容,实现该布局上滑隐藏,下滑显示的效果;下半部分是可滑动的布局,一般设置为RecyclerView,ListView或者时ViewPager等。 二、结合ToolBar效果图： 2.1 具体实现布局文件代码：12345678910111213141516171819202122232425262728293031323334&lt;android.support.design.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;com.sunny.myframedemo.toolbarscroll.ToolBarFragment&quot;&gt; &lt;android.support.design.widget.AppBarLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:theme=&quot;@style/Base.ThemeOverlay.AppCompat.Dark.ActionBar&quot;&gt; &lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/toolBar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?attr/actionBarSize&quot; android:background=&quot;?attr/colorPrimary&quot; app:popupTheme=&quot;@style/Base.ThemeOverlay.AppCompat.Light&quot; app:layout_scrollFlags=&quot;scroll|enterAlways&quot;&gt; &lt;/android.support.v7.widget.Toolbar&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v7.widget.RecyclerView android:id=&quot;@+id/toolbar_recycleView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;&gt; &lt;/android.support.v7.widget.RecyclerView&gt; &lt;android.support.design.widget.FloatingActionButton android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;end|bottom&quot; android:src=&quot;@drawable/add_2&quot;/&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 布局结构为：最外层是CoordinatorLayout，AppBarLayout为它的子布局，使用AppBarLayout将ToolBar包裹，最关键的就是给ToolBar指定layout_scrollFlags属性。 2.2 几个重要的属性2.2.1 Scroll值设为scroll的View会跟随滚动事件一起发生移动。就是当指定的ScrollView发生滚动时，该View也跟随一起滚动，就好像这个View也是属于这个ScrollView一样。 2.2.2 enterAlways值设为enterAlways的View,当任何时候ScrollView往下滚动时，该View会直接往下滚动。而不用考虑ScrollView是否在滚动到最顶部还是哪里。 2.2.3 exitUntilCollapsed值设为exitUntilCollapsed的View，当这个View要往上逐渐“消逝”时，会一直往上滑动，直到剩下的的高度达到它的最小高度后，再响应ScrollView的内部滑动事件。 2.2.4 enterAlwaysCollapsed是enterAlways的附加选项，一般跟enterAlways一起使用，它是指，View在往下“出现”的时候，首先是enterAlways效果，当View的高度达到最小高度时，View就暂时不去往下滚动，直到ScrollView滑动到顶部不再滑动时，View再继续往下滑动，直到滑到View的顶部结束。剩下的就是给recyclerView填充数据了。 三、结合ViewPager效果图： 3.1 具体实现布局代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;android.support.design.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;com.sunny.myframedemo.toolbarscroll.AppBarFragment&quot;&gt; &lt;android.support.design.widget.AppBarLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:theme=&quot;@style/Base.ThemeOverlay.AppCompat.Dark.ActionBar&quot;&gt; &lt;ImageView android:id=&quot;@+id/imageview&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@drawable/beauty2&quot; android:scaleType=&quot;fitXY&quot; app:layout_scrollFlags=&quot;scroll|enterAlways&quot; /&gt; &lt;android.support.design.widget.TabLayout android:id=&quot;@+id/tabs&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignParentBottom=&quot;true&quot; android:background=&quot;?attr/colorPrimary&quot; app:tabIndicatorColor=&quot;@color/colorAccent&quot; app:tabIndicatorHeight=&quot;4dp&quot; app:tabSelectedTextColor=&quot;#000&quot; app:tabTextColor=&quot;#fff&quot;/&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v4.view.ViewPager android:id=&quot;@+id/appbar_viewPager&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;&gt; &lt;/android.support.v4.view.ViewPager&gt; &lt;android.support.design.widget.FloatingActionButton android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;end|bottom&quot; android:src=&quot;@drawable/add_2&quot; /&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 布局结构：布局结构与CoordinatorLayout结合ToolBar类似。这里只要讲解以下TabLayout与ViewPager绑定。 3.2 ViewPager与TabLayout绑定3.2.1 布局布局文件上述已经给出了，这里给出几个TabLayout的几个属性：① app:tabIndicatorColor 表示下划线颜色② app:tabIndicatorHeight 表示下方指示条的高度③ app:tabSelectedTextColor 表示tab被选中后，文字的颜色④ app:tabTextColor 表示tab中字体的颜色 3.2.2 初始化标题栏与fragment① 标题栏初始化12345private String[] mtitle = new String[]&#123; &quot;微博&quot;, &quot;发现&quot;, &quot;相册&quot;&#125;; ② fragment的创建12345678910111213141516171819202122232425262728293031323334353637383940414243public class MyItemFragment extends Fragment &#123; public static MyItemFragment newInstance(String title)&#123; MyItemFragment myItemFragment=new MyItemFragment(); Bundle bundle = new Bundle(); bundle.putString(&quot;Title&quot;, title); myItemFragment.setArguments(bundle); return myItemFragment; &#125; private RecyclerView recyclerView; private String title; private List&lt;String&gt; mList=new ArrayList&lt;&gt;(); @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; // Inflate the layout for this fragment View view= inflater.inflate(R.layout.fragment_my_item, container, false); recyclerView=view.findViewById(R.id.item_recyclerView); Bundle bundle=getArguments(); if (bundle !=null)&#123; title=bundle.getString(&quot;Title&quot;); &#125; LinearLayoutManager layoutManager=new LinearLayoutManager(getActivity()); layoutManager.setOrientation(LinearLayoutManager.VERTICAL); recyclerView.setLayoutManager(layoutManager); initData(); ToolBarAdapter toolBarAdapter=new ToolBarAdapter(mList); recyclerView.setAdapter(toolBarAdapter); return view; &#125; private void initData()&#123; for (int i=0;i&lt;20;i++)&#123; mList.add(&quot;我是第&quot;+i+&quot;个&quot;+title); &#125; &#125; 给fragment的recyclerView中填充数据，然后显示。 3.2.3 为ViewPager创建适配器12345678910111213141516171819202122232425262728293031323334public class MyPagerAdapter extends FragmentPagerAdapter &#123; private List&lt;Fragment&gt; fragmentList; private String[] mTitle; public MyPagerAdapter(FragmentManager fm) &#123; this(fm, null, null); &#125; public MyPagerAdapter(FragmentManager fm, List&lt;Fragment&gt; fragmentList, String[] mTitle) &#123; super(fm); if (fragmentList == null) &#123; fragmentList = new ArrayList&lt;&gt;(); &#125; this.fragmentList = fragmentList; this.mTitle = mTitle; &#125; @Override public Fragment getItem(int position) &#123; return fragmentList.get(position); &#125; @Override public int getCount() &#123; return fragmentList.size(); &#125; @Nullable @Override public CharSequence getPageTitle(int position) &#123; return mTitle[position]; &#125;&#125; 这里需要注意一点，必须重写getPageTitle方法要不然就标题就不会显示出来。 3.2.4 ViewPager与TableLayout绑定1tabLayout.setupWithViewPager(viewPager); 四、结合ViewPager+CollapsingToolbarLayout效果图： 4.1 具体实现界面布局代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;android.support.design.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@android:color/background_light&quot; android:fitsSystemWindows=&quot;true&quot; tools:context=&quot;com.sunny.myframedemo.toolbarscroll.CollapsingFragment&quot;&gt; &lt;android.support.design.widget.AppBarLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;350dp&quot; android:fitsSystemWindows=&quot;true&quot; android:theme=&quot;@style/Base.ThemeOverlay.AppCompat.Dark.ActionBar&quot;&gt; &lt;android.support.design.widget.CollapsingToolbarLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;300dp&quot; android:fitsSystemWindows=&quot;true&quot; app:contentScrim=&quot;?attr/colorPrimary&quot; app:expandedTitleMarginEnd=&quot;64dp&quot; app:expandedTitleMarginStart=&quot;48dp&quot; app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot;&gt; &lt;ImageView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@drawable/beauty3&quot; android:fitsSystemWindows=&quot;true&quot; android:scaleType=&quot;centerCrop&quot; app:layout_collapseMode=&quot;parallax&quot; /&gt; &lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/collap_toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?attr/actionBarSize&quot; app:layout_collapseMode=&quot;pin&quot; app:popupTheme=&quot;@style/Base.ThemeOverlay.AppCompat.Light&quot; /&gt; &lt;/android.support.design.widget.CollapsingToolbarLayout&gt; &lt;android.support.design.widget.TabLayout android:id=&quot;@+id/collap_tablayout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignParentBottom=&quot;true&quot; android:background=&quot;?attr/colorPrimary&quot; app:tabIndicatorColor=&quot;@color/colorAccent&quot; app:tabIndicatorHeight=&quot;4dp&quot; app:tabSelectedTextColor=&quot;#000&quot; app:tabTextColor=&quot;#fff&quot; /&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v4.view.ViewPager android:id=&quot;@+id/collap_viewPager&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;&gt; &lt;/android.support.v4.view.ViewPager&gt; &lt;android.support.design.widget.FloatingActionButton android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;end|bottom&quot; android:layout_margin=&quot;15dp&quot; android:src=&quot;@drawable/add_2&quot;/&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 布局结构如下：AppBarLayout将CollapsingToolBarLayout和TabLayout包裹起来，而在CollapsingToolBarLayout里面包含ImageView和ToolBar #####4.1.1 CollapsingToolBarLayout的3种折叠模式① off： 这个是默认属性，布局将正常显示，没有折叠的行为。②pin：CollapsingToolbarLayout折叠后，此布局将固定在顶部。③parallax：CollapsingToolbarLayout折叠时，此布局也会有视差折叠效果。剩下的就是将ViewPager与TabLayout绑定了，这里就不赘述了。最后附上源码：https://github.com/sunnyslx/CoordinatorLayoutDemo.git","categories":[],"tags":[]},{"title":"详解Android Activity生命周期","slug":"activity","date":"2018-07-31T08:50:42.438Z","updated":"2018-07-31T08:50:42.378Z","comments":true,"path":"2018/07/31/activity/","link":"","permalink":"http://yoursite.com/2018/07/31/activity/","excerpt":"","text":"&emsp;&emsp;Activity作为Android四大组件之首,在程序开发过程中扮演着非常重要的角色,是用户与程序之间进行交互的窗口.理解Activity的生命周期,有助于在开发过程中更好的进行控制逻辑处理.&emsp;&emsp;在Activity生命周期中,系统按照类似于金字塔一样的顺序去调用各个生命周期.当系统创建新的Activity实例时,每个回调方法将Activity状态向前移动一步,金字塔的顶部是Activity在前台运行的点,用户可以与之交互. 一 指定应用程序启动哪个Activity&emsp;&emsp;当用户选择进入应用程序后,系统会调用在程序声明中的Activity的onCreate()方法,这是程序与用户界面交互的入口.这个Activity必须在清单文件下进行声明:注意:当程序创建一个新的Activity时,必须在Manifest.xml文件中进行声明 二 创建一个实例&emsp;&emsp;正常来讲,一个应用程序一般都会有几个Activity,不同Activity用来响应用户不同的操作,只要启动了该Activity,系统就会调用其onCreate()方法创建一个新的Activity实例.1234567891011TextView mTextView; // 布局中TextView的成员变量@Overridepublic void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // 设置此活动的用户界面布局 // 布局文件在项目中定义res/layout/main_activity.xml setContentView(R.layout.main_activity); // 初始化成员TextView，以便我们以后可以操作它 mTextView = (TextView) findViewById(R.id.text_message);&#125; 上述代码中看到,在onCreate()方法中,首先应当给Activity设置相应的布局,然后对布局中的控件进行初始化操作.&emsp;&emsp;在onCreate()方法执行后,系统会连续执行onStart()和onResume()方法,Activity永远都不会处于”已创建”或者”已启动”状态.在调用onStart()时,Activity对用户来讲已经是可见状态,但执行onResume()方法后,Activity会快速保持在恢复状态,知道发生某些变化(接收电话,屏幕关闭) 三 Activity的销毁&emsp;&emsp;Activity的第一个生命周期回调时onCreate(),但它的最后一个回调是onDestory(),系统会将此Activity实例从内存中完全删除.1234@Overridepublic void onDestroy() &#123; super.onDestroy(); &#125; &emsp;&emsp;在onDestory方法中,应该将在onCreate()中创建的线程或者其他长时间的运行资源终止掉.(如果未正确关闭可能会引发内存泄漏).注意:一般是在调用onPause()和onStop()之后调用onDestory(),但如果在程序在onCreate()方法中调用了finish()后,这种情况下,系统就会立即调用onDestory()而不调用其他任何生命周期方法 四 暂停和恢复Activity&emsp;&emsp;在正常的应用程序使用期间,应用程序有时会失去焦点,导致Activity暂停(例如，当应用程序在多窗口模式下运行时，任何时候只有一个应用程序具有焦点)&emsp;&emsp;当ACtivity进入暂停状态时,系统会调用onPause方法,这样就可以暂停不应继续执行的操作,或者是保留一些信息,如果用户从暂停状态回到Activity,系统将恢复并调用onResume()方法. 4.1 暂停当前Activity当系统调用onPuse()方法时,它意味着Activity仍然部分可见,通常应该使用onPuase()回调来:&emsp;&emsp;①检查Activity是否可见,如果不是,应该停止可能消耗CPU的动画或其他正在运行的操作,在Android7.0开始,多窗口模式下也可运行,这个时候就不需要暂停动画或者视频的播放;&emsp;&emsp;② 提交未保存的更改，但前提是用户希望此类更改在离开时永久保存（例如草稿电子邮件）;&emsp;&emsp;③释放系统资源，例如广播接收器，处理传感器（如GPS），或在Activity暂停且用户不需要时可能影响电池寿命的任何资源。例如:应用程序中使用Camera,在onPause()中释放12345678910@Overridepublic void onPause() &#123; super.onPause(); // 释放相机，因为暂停时我们不需要它,而其他Activity可能需要使用它。 if (mCamera != null) &#123; mCamera.release(); mCamera = null; &#125;&#125; 注意:当Activity暂停时，Activity实例将保留在内存中，并在Activity恢复时调用。 不需要重新初始化组件。 4.2 恢复当前Activity&emsp;&emsp;当用户从暂停状态恢复时，系统将调用onResume（）方法,因此程序需要在onResume()方法中来初始化onPuse()期间释放掉的组件。123456789@Overridepublic void onResume() &#123; super.onResume(); // 获取camera实例 if (mCamera == null) &#123; //初始化相机 initializeCamera(); &#125;&#125; 五 停止并重新启动Activity正确停止和重新启动Activity时Activity生命周期中一个重要的过程,Activity停止并重新启动的几种情况:&emsp;&emsp;① 用户打开“最近的应用程序”窗口，并从当前应用程序切换到另一个应用时, 应用中当前位于前台的Activity已停止。 如果用户从主屏幕打开应用程序或从“最近的应用程序”窗口返回，则Activity将重新启动。&emsp;&emsp;②当前Activity被新的Activity覆盖。创建第二个Activity时，将停止当前Activity。 如果用户然后按“返回”按钮，则重新启动第一个Activity。&emsp;&emsp;③使用当前应用程序时会接到电话。Activity提供了onStop()和onRestart()方法,它们用来处理Activity停止和重新启动的方式.与暂停状态不同的是,停止状态UI不在可见,并且用户的焦点位于单独的Activity中.注意:当用户离开Activity时，系统调用onStop（）来停止活动（1）。 如果用户在活动停止时返回，则系统调用onRestart（）（2），然后快速调用onStart（）（3）和onResume（）（4）。 请注意，无论何种情况导致活动停止，系统始终在调用onStop（）之前调用onPause（）。 5.1 停止Activity&emsp;&emsp;当Activity收到对onStop（）方法的调用时，它将不再可见，并且应该释放用户未使用时几乎所有不需要的资源。一旦Activity停止，系统可能会在需要恢复系统内存时销毁该实例。在极端情况下，系统可能只是在不调用Activity的onDestroy（）回调的情况下杀死应用程序进程，因此使用onStop（）释放可能泄漏内存的资源是可行的。虽然在onStop（）之前调用了onPause（）方法，但是应该使用onStop（）来执行更大，更密集的CPU关闭操作，例如将信息写入数据库。例如，这是onStop（）的一个实现，它将草稿注释的内容保存到持久存储：123456789101112131415@Overrideprotected void onStop() &#123; super.onStop(); // 保存笔记的当前草稿，因为Activity正在停止,我们希望确保当前笔记进度不会丢失。 ContentValues values = new ContentValues(); values.put(NotePad.Notes.COLUMN_NAME_NOTE, getCurrentNoteText()); values.put(NotePad.Notes.COLUMN_NAME_TITLE, getCurrentNoteTitle()); getContentResolver().update( mUri, values, null, null );&#125; 5.2 重新启动Activity&emsp;&emsp;当Activity从停止状态返回到前台时，它会收到对onRestart（）的调用。系统还调用onStart（）方法，该方法在每次Activity可见时（无论是重新启动还是第一次创建）都会发生。但是，只有当Activity从停止状态恢复时才会调用onRestart（）方法，因此可以使用它来执行特殊的恢复工作，这可能只有在Activity先前已停止但未被销毁时才需要。&emsp;&emsp;应用程序需要使用onRestart（）来恢复Activity的状态并不常见，因此此方法没有适用于一般应用程序的任何准则。但是，因为onStop（）方法应该基本上清理所有Activity的资源，所以当Activity重新启动时，需要重新实例化它们。 但是，当第一次创建Activity时（当没有Activity的现有实例时），还需要实例化它们。 因此，通常应该使用onStart（）回调方法作为onStop（）方法的对应方法，因为系统在创建活动时以及从停止状态重新启动活动时都会调用onStart（）。1234567891011@Overrideprotected void onStart() &#123; super.onStart(); //活动要么重新启动，要么首次启动&#125;@Overrideprotected void onRestart() &#123; super.onRestart(); // 从停止状态重新启动的活动&#125; 六 重新创建活动&emsp;&emsp;当Activity因用户按下Back或Activity自行完成而被销毁时，系统对该Activity实例的概念将永远消失，因为该行为表明不再需要该Activity。但是，如果系统因系统约束（而不是正常的应用程序行为）而破坏Activity，那么虽然实际的Activity实例已经消失，但系统会记住它存在，如果用户导航回到它，系统会创建一个新的Activity实例，使用一组保存的数据来描述销毁时的Activity状态。系统用于恢复先前状态的已保存数据称为“实例状态”，是存储在Bundle对象中的键值对的集合。&emsp;&emsp;要保存有关Activity状态的其他数据，必须覆盖onSaveInstanceState（）回调方法。系统在用户离开Activity时调用此方法，并向其传递Bundle对象，该对象将在Activity意外销毁时保存。如果系统必须稍后重新创建Activity实例，它会将相同的Bundle对象传递给onRestoreInstanceState（）和onCreate（）方法。 6.1 保存Activity状态&emsp;&emsp;当Activity开始停止时，系统会调用onSaveInstanceState（），以便Activity可以使用一组键值对来保存状态信息。此方法的默认实现保存有关Activity视图层次结构状态的信息，例如EditText小部件中的文本或ListView的滚动位置。要保存活动的其他状态信息，必须实现onSaveInstanceState（）并将键值对添加到Bundle对象。 例如：12345678910static final String STATE_SCORE = &quot;playerScore&quot;;static final String STATE_LEVEL = &quot;playerLevel&quot;;@Overridepublic void onSaveInstanceState(Bundle savedInstanceState) &#123; // 保存用户当前的游戏状态 savedInstanceState.putInt(STATE_SCORE, mCurrentScore); savedInstanceState.putInt(STATE_LEVEL, mCurrentLevel); super.onSaveInstanceState(savedInstanceState);&#125; 6.2 恢复Activity状态&emsp;&emsp;在先前销毁活动之后重新创建活动时，您可以从系统传递活动的Bundle中恢复已保存的状态。 onCreate（）和onRestoreInstanceState（）回调方法都接收包含实例状态信息的相同Bundle。&emsp;&emsp;因为无论系统是创建活动的新实例还是重新创建前一个实例，都会调用onCreate（）方法，因此在尝试读取之前必须检查状态Bundle是否为null。 如果它为null，则系统正在创建活动的新实例，而不是恢复已销毁的先前实例。例如，以下是如何在onCreate（）中恢复某些状态数据：1234567891011121314@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // Always call the superclass first // Check whether we&apos;re recreating a previously destroyed instance if (savedInstanceState != null) &#123; // 从已保存状态恢复成员的值 mCurrentScore = savedInstanceState.getInt(STATE_SCORE); mCurrentLevel = savedInstanceState.getInt(STATE_LEVEL); &#125; else &#123; // 可能使用新实例的默认值初始化成员 &#125; &#125; 可以选择实现onRestoreInstanceState（），系统在onStart（）方法之后调用on而不是在onCreate（）期间恢复状态。 仅当存在要恢复的已保存状态时，系统才会调用onRestoreInstanceState（），因此您无需检查Bundle是否为null：1234567public void onRestoreInstanceState(Bundle savedInstanceState) &#123; super.onRestoreInstanceState(savedInstanceState); // 从已保存的实例恢复状态成员 mCurrentScore = savedInstanceState.getInt(STATE_SCORE); mCurrentLevel = savedInstanceState.getInt(STATE_LEVEL);&#125; 七 总结","categories":[],"tags":[]},{"title":"Android 自定义View","slug":"view-md","date":"2018-07-31T02:51:38.542Z","updated":"2018-07-31T02:51:38.466Z","comments":true,"path":"2018/07/31/view-md/","link":"","permalink":"http://yoursite.com/2018/07/31/view-md/","excerpt":"","text":"前言&emsp; &emsp;首先我们先了解一下,什么叫view?Android官方文档对View的解释是这样的:表示用户界面组件的基本构建块,视图占据屏幕上的矩形区域，负责绘图和事件处理。以上可以看出view是程序与用户之间进行交互的桥梁。view的形状,大小,表现形式多种多样,所有就会发现Android系统能提供给我们的有时候并不能满足我们的需求,所以就会需要程序员去自定义view。&emsp; &emsp;下面我就介绍以下如何自定义view,我将自定义View基础、自定义View绘制流程、事件分发机制这三个方面来介绍。 一 自定义View基础1.1 坐标系屏幕坐标系与数学坐标系的差异 1.1.1 屏幕坐标系 1.1.1 view的坐标系注意：View的坐标系都是相对于父控件而言。 1.2 颜色三原色 1.3 分类根据用途来分，一般将自定义分为两种：即自定义控件和自定义布局. 1.4 自定义属性自定义属性步骤 二 自定义view绘制流程2.1 绘制流程 2.2 相关函数介绍2.2.1 构造函数一个参的构造，一般在java代码中直接new一个View时调用。 两个参的构造，一般在Layout文件中使用的时候调用，关于它的所有属性（包括自定义属性）都会通过attrs传递进来。 三个参数的构造，第三个参数是默认的Style，这里的默认的Style是指它在当前Application或Activity所用的Theme中的默认Style。四个参数的构造，第四个参数是指向一个style的ID，但是是在defStyleAttr为0,或者defStyle不为0，但theme没有为defStyleAttr属性赋值时起作用。 2.2.2 测量view的大小函数-onMeasure()作用：测量View的大小，并从widthMeasureSpec 和 heightMeasureSpec中取出宽高的相关数据，它们其实不是宽和高， 而是由宽、高和各自方向上对应的测量模式来合成的一个值。测量模式:三种测量模式,通过MeasureSpec.getMode()得到测量模式， Measure.getSize()得到测量数值。 2.2.3 确定view的大小函数-onSizeChanged()作用：确定View大小,在视图大小发生改变时调用,它有四个参数，分别为宽度，高度，上一次宽度，上一次高度。 2.2.4 确定子view的布局-onLayout()作用：它用于确定子View的位置，在自定义ViewGroup中会用到，他调用的是子View的layout函数。它有四个参数如下： 2.2.5 绘制view的函数-onDraw()作用：绘制内容，使用canvas进行绘图. 三 事件分发机制为什么要有事件分发机制？有时候界面上的view并不是很规则整齐的排列在一起,View之间是有可能重叠在一起的，当我们点击的地方有多个View响应时，这个点击事件应该分发给谁？为了解决这一部分就有了事件分发机制。 3.1 事件分发核心函数以上三个方法都有一个boolean类型的返回值，通过返回true或者false来控制事件的流程. 3.2 事件分发流程责任链模式，即如果自己能处理就拦截下来自己处理，如果不能处理或者不确定就交给责任链中的下一个对象。如下图： 3.2.1 事件分发机制流程详解事件传递顺序:注意：事件传递过程先执行分发,再执行拦截,事件传递返回 true,表示事件被拦截，交给自己的onTouchEvent处理；false,表示不拦截，向下传递。事件处理顺序:注意：事件的处理都要进过onTouchEvent，事件处理返回true，表示事件自己处理，false，表示向上传递。 3.2.2 事件分发机制流程概括 (1)事件如果被消费，就意味着事件传递消息被终止。 (2)如果事件一直没有被消费就会传递给activity，如果activity也不需要就会被抛弃。 (3)判断事件是否被消费是根据返回值，并不是根据你是否使用了该事件。 Android 事件分发，一般可以理解为：&emsp; &emsp;(a)ViewGroup对点击事件的分发机制。&emsp; &emsp;(b)View对点击事件的分发机制。 3.3 MotionEvent对象根据面向对象的思想，事件被封装成MotionEvent对象。对于单指触控来说，一次简单的交互流程是： 3.4 ViewGroup的事件分发注意：ViewGroup的事件分发不仅要考虑自身，还要考虑子View.ViewGroup的分发流程: 3.4.1 子view存在重合点时的处理情况一： &emsp; &emsp;只有View1可以点击时，该点击事件分配给View1情况二： &emsp; &emsp;只有View2可以点击时，该点击事件分配给View2情况三： &emsp; &emsp;View1、View2均可点击时，该点击事件分配给View2,如果View2将事件消费掉了，则View1将接收不到. 3.4.2 view的可点击情况分类: &emsp; &emsp;onClick &emsp; &emsp;onLongClick &emsp; &emsp;onContextClick &emsp; &emsp;android:clickable=“true” &emsp; &emsp;button ,ImageButton,CheckBox默认是可点击的。 3.5 view的事件分发流程 3.6 总结以上只是个人对自定义view的理解.有不对的地方,欢迎指正!","categories":[],"tags":[]},{"title":"如何在ubuntu搭建Android开发环境","slug":"environment","date":"2018-07-30T10:34:57.446Z","updated":"2018-07-30T10:34:57.382Z","comments":true,"path":"2018/07/30/environment/","link":"","permalink":"http://yoursite.com/2018/07/30/environment/","excerpt":"","text":"要进行程序的开发前提是:搭建开发环境下面我就介绍一下如何搭建Android开发环境. 一 安装jdkAndroid开发使用的语言是java,既然要使用java这就要牵扯到jdk了.步骤:1.1 下载jdk.官网地址:http://www.oracle.com/technetwork/java/javase/downloads1.2 解压安装.&emsp;&emsp;(1)进入home目录下,终端输入 cd ~&emsp;&emsp;(2)更新套件资讯:&emsp;&emsp;&emsp;&emsp;①打开Ubuntu系统设置,设置HTTP、HTTPS网络代理以及端口&emsp;&emsp;&emsp;&emsp;②终端输入：sudo gedit /etc/apt/apt.conf&emsp;&emsp;&emsp;&emsp;③在打开文件中，输入上网代理账号和密码，保存退出 Acquire::http::proxy “http://username:password@ip地址+端口号/&quot;; Acquire::https::proxy “https://username:password@ip地址+端口号/&quot;;&emsp;&emsp;&emsp;&emsp;④ 更新，终端输入:sudo apt-get update1.3 新建jdk安装目录jvm,命令:sudo mkdir /usr/lib/jvm1.4 解压JDK至jvm&emsp;&emsp;① 进入JDK压缩档所在目录：cd 目录&emsp;&emsp;② 解压，终端输入：sudo tar -zxvf ./jdk-8u91-linux-x64.tar.gz -C /usr/lib/jvm1.5 重命名：sudo mv /usr/lib/jvm/jdk1.8.0_91/ /usr/lib/jvm/jdk180911.6 安装其他工具: sudo apt-get install git-core gnupg flex bison gperf build-essential zip curl zlib1g-dev libc6-dev lib32ncurses5-dev x11proto-core-dev libx11-dev lib32readline-gplv2-dev lib32z1-dev libgl1-mesa-dev g++-multilib mingw32 tofrodos python-markdown libxml2-utils xsltproc 二 配置jdk环境变量2.1 编辑~/.bashrc 输入sudo gedit ~/.bashrc打开，在文件末尾加入&emsp;&emsp;export JAVA_HOME=/usr/lib/jvm/jdk18091&emsp;&emsp;export JRE_HOME=${JAVA_HOME}/jre&emsp;&emsp;export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib&emsp;&emsp;export PATH=${JAVA_HOME}/bin:$PATH2.2 终端输入：java -version，查询到JDK版本，配置成功 三 安装Android Studio3.1 下载Android studio 下载地址 http://www.android-studio.org3.2 解压安装&emsp;&emsp;(1) 在home目录中新建安装目录installed&emsp;&emsp;(2) 解压压缩档至installed&emsp;&emsp;(3) 启动Android Studio， 终端输入：~/installed/android-studio/bin/studio.sh&emsp;&emsp;(4) Android Studio 启动后可选择在线下载SDK，或指定一个已有SDK目录&emsp;&emsp;(5)启动Android Studio后，在Configure中单击Create Desktop Entry，再在左侧图标右键选择lock 四 配置sdk环境变量4.1 编辑~/.bashrc(1) 终端输入sudo gedit ~/.bashrc(2) 在打开文件末尾加入export ANDROID_SDK=/home/用户名/installed/sdkexport PATH=${ANDROID_SDK}/platform-tools:${ANDROID_SDK}/tools:$PATH(3) 终端输入：adb version，查询到版本号，配置成功开发环境配置完毕后,下面就可以进行愉快的开发之旅了!","categories":[],"tags":[]},{"title":"如何高效的显示Bitmap","slug":"bitmap","date":"2018-07-28T10:28:00.028Z","updated":"2018-07-28T10:27:59.980Z","comments":true,"path":"2018/07/28/bitmap/","link":"","permalink":"http://yoursite.com/2018/07/28/bitmap/","excerpt":"","text":"前言了解如何使用常用技术来处理和加载Bitmap，使我们的UI组件保持响应并避免超出应用程序内存限制。如果不小心，Bitmap可以快速消耗你的可用内存预算，导致应用程序崩溃，出现OOM.为什么在Android应用程序中加载Bitmap是件很棘手的事情?&emsp;&emsp; ①移动设备资源受限.Android设备可以为当个应用程序提供少至16MB的内存,所有应当优化应用程序以在最小的内存限制下都可执行。 &emsp;&emsp; ②Bitmap占用了大量的内存,特别是对于像照片这样的丰富图像,如果使用的位图配置时ARGB_8888(Android系统默认),以10801920像素的照片为例,则将此图像加载到内存中大约需要8M内存(10801920*4字节),这样会立即耗尽某些设备上的每个应用程序限制。 &emsp;&emsp; ③Android应用UI通常需要一次就加载几个Bitmap.像ListView,GridView和ViewPager等组件通常就会同时在屏幕上显示几张Bitmap。 一.有效的加载大的Bitmap不超出每个应用程序内存限制的情况下解码大的Bitmp，方法是在内存中加载较小的Bitmap。 1.1读取Bitmap的尺寸和类型BitmapFactory类提供了几种解码方法（decodeByteArray（），decodeFile（），decodeResource（）等），用于从各种源创建Bitmap。 根据图像数据源选择最合适的解码方法。 这些方法尝试为构造的位图分配内存，因此很容易导致OOM异常。 每种类型的解码方法都有其他签名，可通过BitmapFactory.Options类指定解码选项。 解码时将inJustDecodeBounds属性设置为true可避免内存分配，为位图对象返回null，但设置outWidth，outHeight和outMimeType.该方式允许在构造（和内存分配）位图之前读取图像数据的尺寸和类型。123456BitmapFactory.Options options = new BitmapFactory.Options();options.inJustDecodeBounds = true;BitmapFactory.decodeResource(getResources(), R.id.myimage, options);int imageHeight = options.outHeight;int imageWidth = options.outWidth;String imageType = options.outMimeType; 要避免OOM,就需要在解码之前检查Bitmap的尺寸. 1.2将缩小的Bitmap加载到内存中图像尺寸大小已知,它们就可决定是否将完整的图像加载到内存中,或者是够应加载小的Bitmap,以下时需要考虑的因素:&emsp;&emsp; ①估计在内存中加载完整映像的内存使用情况。&emsp;&emsp; ②在给定应用程序的任何其他内存要求的情况下，可以加载此映像的内存量。&emsp;&emsp; ③要加载图像的目标ImageView或UI组件的尺寸。&emsp;&emsp; ④屏幕尺寸和当前设备的密度。要告诉解码器将较小的Bitmap加载到内存中,就需要将BitmapFactory.Options对象中的inSampleSize设置为true。以下是根据目标宽度和高度计算本大小值的方法:123456789101112131415161718public static int calculateInSampleSize( BitmapFactory.Options options, int reqWidth, int reqHeight) &#123; //图像的原始高度和宽度 final int height = options.outHeight; final int width = options.outWidth; int inSampleSize = 1; if (height &gt; reqHeight || width &gt; reqWidth) &#123; final int halfHeight = height / 2; final int halfWidth = width / 2; //计算最大的inSampleSize值，该值为2次幂并保持两者 //高度和宽度大于要求的高度和宽度。 while ((halfHeight / inSampleSize) &gt;= reqHeight &amp;&amp; (halfWidth / inSampleSize) &gt;= reqWidth) &#123; inSampleSize *= 2; &#125; &#125; return inSampleSize;&#125; 注意:计算两个幂的幂是因为解码器使用最终值通过舍入到最接近的2次幂要使用此方法，首先使用inJustDecodeBounds设置为true进行解码，传递选项，然后使用新的inSampleSize值再次解码，并将inJustDecodeBounds设置为false123456789101112public static Bitmap decodeSampledBitmapFromResource(Resources res, int resId, int reqWidth, int reqHeight) &#123; // 首先使用inJustDecodeBounds = true进行解码以检查尺寸 final BitmapFactory.Options options = new BitmapFactory.Options(); options.inJustDecodeBounds = true; BitmapFactory.decodeResource(res, resId, options); // 计算inSampleSize options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight); // 使用inSampleSize设置解码位图 options.inJustDecodeBounds = false; return BitmapFactory.decodeResource(res, resId, options);&#125; 此方法可以轻松地将任意大尺寸的位图加载到显示100x100像素缩略图的ImageView中，如以下示例代码所示：12mImageView.setImageBitmap( decodeSampledBitmapFromResource(getResources(), R.id.myimage, 100, 100)); 二.关闭UI线程处理Bitmap如果从磁盘或网络位置（或实际上除内存之外的任何其他源）读取源数据，则不应在主UI线程上执行BitmapFactory.decode *方法。 因为这些数据加载所需的时间是不可预测的，取决于各种因素（从磁盘或网络读取的速度，映像的大小，CPU的功率等）。如果其中一个任务阻止了UI线程，系统会将应用程序标记为无响应，并且用户可以选择关闭它。下面主要是讲如何使用AsyncTask处理后台线程中的Bitmap。 2.1 使用AsyncTaskAsyncTask类提供了一种在后台线程中执行某些工作并将结果发布回UI线程的简单方法。要使用它，就需要创建一个子类并覆盖提供的方法。下面是使用AsyncTask和decodeSampledBitmapFromResource（）将大图像加载到ImageView的示例：123456789101112131415161718192021222324252627class BitmapWorkerTask extends AsyncTask&lt;Integer, Void, Bitmap&gt; &#123; private final WeakReference&lt;ImageView&gt; imageViewReference; private int data = 0; public BitmapWorkerTask(ImageView imageView) &#123; // 使用WeakReference确保可以对ImageView进行垃圾回收 imageViewReference = new WeakReference&lt;ImageView&gt;(imageView); &#125; // 在后台解码图像。 @Override protected Bitmap doInBackground(Integer... params) &#123; data = params[0]; return decodeSampledBitmapFromResource(getResources(), data, 100, 100)); &#125; // 完成后，查看ImageView是否仍然存在并设置Bitmap。 @Override protected void onPostExecute(Bitmap bitmap) &#123; if (imageViewReference != null &amp;&amp; bitmap != null) &#123; final ImageView imageView = imageViewReference.get(); if (imageView != null) &#123; imageView.setImageBitmap(bitmap); &#125; &#125; &#125;&#125; 对ImageView的WeakReference确保AsyncTask不会阻止ImageView及其引用的任何内容被垃圾回收。 当任务完成时，无法保证ImageView仍然存在，因此还必须检查onPostExecute（）中的引用。要开始异步加载位图，只需创建一个新任务并执行它：1234public void loadBitmap(int resId, ImageView imageView) &#123; BitmapWorkerTask task = new BitmapWorkerTask(imageView); task.execute(resId);&#125; 2.2 处理并发当与AsyncTask结合使用时，ListView和GridView等常见视图组件会引入另一个问题，如上一节所示。 为了提高内存的效率，这些组件会在用户滚动时回收子视图。 如果每个子视图都触发AsyncTask，则无法保证在完成时，关联的视图尚未被回收以在另一个子视图中使用。 此外，无法保证异步任务的启动顺序是它们完成的顺序。创建一个专用的Drawable子类，以将引用存储回worker任务。 在这种情况下，使用BitmapDrawable，以便在任务完成时可以在ImageView中显示占位符图像：1234567891011121314static class AsyncDrawable extends BitmapDrawable &#123; private final WeakReference&lt;BitmapWorkerTask&gt; bitmapWorkerTaskReference; public AsyncDrawable(Resources res, Bitmap bitmap, BitmapWorkerTask bitmapWorkerTask) &#123; super(res, bitmap); bitmapWorkerTaskReference = new WeakReference&lt;BitmapWorkerTask&gt;(bitmapWorkerTask); &#125; public BitmapWorkerTask getBitmapWorkerTask() &#123; return bitmapWorkerTaskReference.get(); &#125;&#125; 在执行BitmapWorkerTask之前，需要创建一个AsyncDrawable并将其绑定到目标ImageView：123456789public void loadBitmap(int resId, ImageView imageView) &#123; if (cancelPotentialWork(resId, imageView)) &#123; final BitmapWorkerTask task = new BitmapWorkerTask(imageView); final AsyncDrawable asyncDrawable = new AsyncDrawable(getResources(), mPlaceHolderBitmap, task); imageView.setImageDrawable(asyncDrawable); task.execute(resId); &#125;&#125; 上面的代码示例中引用的cancelPotentialWork方法检查另一个正在运行的任务是否已与ImageView关联。 如果是，则尝试通过调用cancel（）取消先前的任务。 在少数情况下，新任务数据与现有任务匹配，不需要进一步发生任何事情。 这是cancelPotentialWork的实现：1234567891011121314151617public static boolean cancelPotentialWork(int data, ImageView imageView) &#123; final BitmapWorkerTask bitmapWorkerTask = getBitmapWorkerTask(imageView); if (bitmapWorkerTask != null) &#123; final int bitmapData = bitmapWorkerTask.data; //如果尚未设置bitmapData或它与新数据不同 if (bitmapData == 0 || bitmapData != data) &#123; // 取消上一个任务 bitmapWorkerTask.cancel(true); &#125; else &#123; // 同样的工作已在进行中 return false; &#125; &#125; // 没有与ImageView关联的任务，或者已取消现有任务 return true;&#125; 上面使用了一个帮助方法getBitmapWorkerTask（）来检索与特定ImageView关联的任务：12345678910private static BitmapWorkerTask getBitmapWorkerTask(ImageView imageView) &#123; if (imageView != null) &#123; final Drawable drawable = imageView.getDrawable(); if (drawable instanceof AsyncDrawable) &#123; final AsyncDrawable asyncDrawable = (AsyncDrawable) drawable; return asyncDrawable.getBitmapWorkerTask(); &#125; &#125; return null;&#125; 最后一步是更新BitmapWorkerTask中的onPostExecute（），以便检查任务是否被取消以及当前任务是否与ImageView相关联的任务匹配：12345678910111213141516171819class BitmapWorkerTask extends AsyncTask&lt;Integer, Void, Bitmap&gt; &#123; ... @Override protected void onPostExecute(Bitmap bitmap) &#123; if (isCancelled()) &#123; bitmap = null; &#125; if (imageViewReference != null &amp;&amp; bitmap != null) &#123; final ImageView imageView = imageViewReference.get(); final BitmapWorkerTask bitmapWorkerTask = getBitmapWorkerTask(imageView); if (this == bitmapWorkerTask &amp;&amp; imageView != null) &#123; imageView.setImageBitmap(bitmap); &#125; &#125; &#125;&#125; 此实现现在适用于ListView和GridView组件以及回收其子视图的任何其他组件。 只需调用loadBitmap，我们通常会将图像设置为ImageView。 例如，在GridView实现中，这将在后备适配器的getView（）方法中。 三.缓存位图将单个Bitmap加载到用户界面（UI）非常简单，但是如果需要一次加载更多的图像，事情会变得更加复杂。 在许多情况下（例如使用ListView，GridView或ViewPager等组件），屏幕上的图像总数与可能很快滚动到屏幕上的图像基本上是无限的。通过在子屏幕移动时回收子视图，可以使用这样的组件来降低内存使用率。 垃圾收集器还可以释放加载的Bitmap，假设在没有保留任何长期存在的引用。 这一切都很好，但为了保持流畅和快速加载的UI，我们希望避免每次它们回到屏幕时不断处理这些图像。 内存和磁盘缓存通常可以在这里提供帮助，允许组件快速重新加载已处理的映像。下面将介绍使用内存和磁盘位图缓存来提高加载多个位图时UI的响应能力和流动性。 3.1 使用内存缓存内存缓存以占用宝贵的应用程序内存为代价提供对位图的快速访问。 LruCache类（也可在支持库中使用，可用于API级别4）特别适合缓存位图，将最近引用的对象保存在强引用的LinkedHashMap中，并在缓存超过其之前驱逐最近最少使用的成员 指定大小。以下是为Bitmap设置LruCache的示例：12345678910111213141516171819202122232425262728293031private LruCache&lt;String, Bitmap&gt; mMemoryCache;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; ... //获取最大可用VM内存，超过此数量将抛出一个OOM异常。 以LruCache为单位存储为千字节 //在其构造函数中进行定义。 final int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024); // 使用此内存缓存的1/8可用内存。 final int cacheSize = maxMemory / 8; mMemoryCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) &#123; @Override protected int sizeOf(String key, Bitmap bitmap) &#123; //缓存大小将以千字节为单位 return bitmap.getByteCount() / 1024; &#125; &#125;; ...&#125;public void addBitmapToMemoryCache(String key, Bitmap bitmap) &#123; if (getBitmapFromMemCache(key) == null) &#123; mMemoryCache.put(key, bitmap); &#125;&#125;public Bitmap getBitmapFromMemCache(String key) &#123; return mMemoryCache.get(key);&#125; 将位图加载到ImageView时，首先检查LruCache。 如果找到条目，则立即使用它来更新ImageView，否则会生成后台线程来处理图像：123456789101112public void loadBitmap(int resId, ImageView imageView) &#123; final String imageKey = String.valueOf(resId); final Bitmap bitmap = getBitmapFromMemCache(imageKey); if (bitmap != null) &#123; mImageView.setImageBitmap(bitmap); &#125; else &#123; mImageView.setImageResource(R.drawable.image_placeholder); BitmapWorkerTask task = new BitmapWorkerTask(mImageView); task.execute(resId); &#125;&#125; 还需要更新BitmapWorkerTask以将条目添加到内存缓存：123456789101112class BitmapWorkerTask extends AsyncTask&lt;Integer, Void, Bitmap&gt; &#123; ... // Decode image in background. @Override protected Bitmap doInBackground(Integer... params) &#123; final Bitmap bitmap = decodeSampledBitmapFromResource( getResources(), params[0], 100, 100)); addBitmapToMemoryCache(String.valueOf(params[0]), bitmap); return bitmap; &#125; ...&#125; 3.2 使用磁盘缓存内存缓存对于加快对最近查看的位图的访问非常有用，但是不能依赖此缓存中可用的图像。 具有较大数据集的GridView等组件可以轻松填充内存缓存。 应用程序可能会被其他任务（例如电话呼叫）中断，而在后台，它可能会被终止并且内存缓存会被破坏。 用户恢复后，应用程序必须再次处理每个图像。在这些情况下，可以使用磁盘缓存来保留已处理的位图，并有助于减少内存缓存中不再提供映像的加载时间。 当然，从磁盘获取图像比从内存加载要慢，并且应该在后台线程中完成，因为磁盘读取时间可能是不可预测的。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394private DiskLruCache mDiskLruCache;private final Object mDiskCacheLock = new Object();private boolean mDiskCacheStarting = true;private static final int DISK_CACHE_SIZE = 1024 * 1024 * 10; // 10MBprivate static final String DISK_CACHE_SUBDIR = &quot;thumbnails&quot;;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; ... // 初始化内存缓存 ... // 在后台线程上初始化磁盘缓存 File cacheDir = getDiskCacheDir(this, DISK_CACHE_SUBDIR); new InitDiskCacheTask().execute(cacheDir); ...&#125;class InitDiskCacheTask extends AsyncTask&lt;File, Void, Void&gt; &#123; @Override protected Void doInBackground(File... params) &#123; synchronized (mDiskCacheLock) &#123; File cacheDir = params[0]; mDiskLruCache = DiskLruCache.open(cacheDir, DISK_CACHE_SIZE); mDiskCacheStarting = false; // 完成初始化 mDiskCacheLock.notifyAll(); // 唤醒所有等待的线程 &#125; return null; &#125;&#125;class BitmapWorkerTask extends AsyncTask&lt;Integer, Void, Bitmap&gt; &#123; ... // 在后台解码图像。 @Override protected Bitmap doInBackground(Integer... params) &#123; final String imageKey = String.valueOf(params[0]); // 检查后台线程中的磁盘缓存 Bitmap bitmap = getBitmapFromDiskCache(imageKey); if (bitmap == null) &#123; // 在磁盘缓存中找不到 // 正常处理 final Bitmap bitmap = decodeSampledBitmapFromResource( getResources(), params[0], 100, 100)); &#125; // 最终Bitmap添加到缓存 addBitmapToCache(imageKey, bitmap); return bitmap; &#125; ...&#125;public void addBitmapToCache(String key, Bitmap bitmap) &#123; // 添加到内存缓存 if (getBitmapFromMemCache(key) == null) &#123; mMemoryCache.put(key, bitmap); &#125; // 添加到磁盘缓存 synchronized (mDiskCacheLock) &#123; if (mDiskLruCache != null &amp;&amp; mDiskLruCache.get(key) == null) &#123; mDiskLruCache.put(key, bitmap); &#125; &#125;&#125;public Bitmap getBitmapFromDiskCache(String key) &#123; synchronized (mDiskCacheLock) &#123; // 等待从后台线程启动磁盘缓存 while (mDiskCacheStarting) &#123; try &#123; mDiskCacheLock.wait(); &#125; catch (InterruptedException e) &#123;&#125; &#125; if (mDiskLruCache != null) &#123; return mDiskLruCache.get(key); &#125; &#125; return null;&#125;//创建指定应用程序缓存目录的唯一子目录。 试图使用外部,但如果没有安装，则回退到内部存储。public static File getDiskCacheDir(Context context, String uniqueName) &#123;检查是否已安装介质或内置存储，如果是，请尝试使用外部缓存目录 否则使用内部缓存目录 final String cachePath = Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState()) || !isExternalStorageRemovable() ? getExternalCacheDir(context).getPath() : context.getCacheDir().getPath(); return new File(cachePath + File.separator + uniqueName);&#125; 在UI线程中检查内存高速缓存时，将在后台线程中检查磁盘高速缓存。 磁盘操作绝不应该在UI线程上进行。 图像处理完成后，最终的Bitmap将添加到内存和磁盘缓存中以备将来使用。 3.3 处理配置更改运行时配置更改（例如屏幕方向更改）会导致Android使用新配置销毁并重新启动运行活动。 避免再次处理所有图像，以便在发生配置更改时，用户可以获得流畅，快速的体验。不过可以使用通过调用setRetainInstance（true）保留的Fragment将此高速缓存传递给新的Activity实例。 重新创建Activity后，将重新附加此保留的Fragment，可以访问现有的缓存对象，从而可以快速获取图像并将其重新填充到ImageView对象中。下面介绍在配置更改中保留LruCache对象的示例：1234567891011121314151617181920212223242526272829303132333435363738private LruCache&lt;String, Bitmap&gt; mMemoryCache;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; ... RetainFragment retainFragment = RetainFragment.findOrCreateRetainFragment(getFragmentManager()); mMemoryCache = retainFragment.mRetainedCache; if (mMemoryCache == null) &#123; mMemoryCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) &#123; ... // 初始化缓存 &#125; retainFragment.mRetainedCache = mMemoryCache; &#125; ...&#125;class RetainFragment extends Fragment &#123; private static final String TAG = &quot;RetainFragment&quot;; public LruCache&lt;String, Bitmap&gt; mRetainedCache; public RetainFragment() &#123;&#125; public static RetainFragment findOrCreateRetainFragment(FragmentManager fm) &#123; RetainFragment fragment = (RetainFragment) fm.findFragmentByTag(TAG); if (fragment == null) &#123; fragment = new RetainFragment(); fm.beginTransaction().add(fragment, TAG).commit(); &#125; return fragment; &#125; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setRetainInstance(true); &#125;&#125; 四.管理Bitmap内存除了缓存位图中描述的步骤之外，还可以执行一些特定操作来促进垃圾收集和位图重用。 4.1 在Android 3.0及更高版本上管理内存4.1.1 保存Bitmap供以后使用以下代码段演示了如何存储现有位图，以便以后在示例应用程序中使用。 当应用程序在Android 3.0或更高版本上运行并且位图从LruCache中逐出时，对位图的软引用将放置在HashSet中，以便稍后可以在inBitmap中重用：123456789101112131415161718192021222324252627282930Set&lt;SoftReference&lt;Bitmap&gt;&gt; mReusableBitmaps;private LruCache&lt;String, BitmapDrawable&gt; mMemoryCache;//如果在Honeycomb或更新版本上运行，请创建一个synchronized HashSet对可重用位图的引用。if (Utils.hasHoneycomb()) &#123; mReusableBitmaps = Collections.synchronizedSet(new HashSet&lt;SoftReference&lt;Bitmap&gt;&gt;());&#125;mMemoryCache = new LruCache&lt;String, BitmapDrawable&gt;(mCacheParams.memCacheSize) &#123; // 通知已删除的不再缓存的条目。 @Override protected void entryRemoved(boolean evicted, String key, BitmapDrawable oldValue, BitmapDrawable newValue) &#123; if (RecyclingBitmapDrawable.class.isInstance(oldValue)) &#123; //删除的条目是回收可绘制的，因此需要通知它已从内存缓存中删除。 ((RecyclingBitmapDrawable) oldValue).setIsCached(false); &#125; else &#123; // 删除的条目是标准的BitmapDrawable。 if (Utils.hasHoneycomb()) &#123; //我们在Honeycomb或更高版本上运行，因此添加位图到一个SoftReference //集合，以便以后可能与inBitmap一起使用。 mReusableBitmaps.add (new SoftReference&lt;Bitmap&gt;(oldValue.getBitmap())); &#125; &#125; &#125;....&#125; 4.1.2 使用现有Bitmap在运行的应用程序中，解码器方法检查是否存在可以使用的现有Bitmap。 例如：123456789101112131415public static Bitmap decodeSampledBitmapFromFile(String filename, int reqWidth, int reqHeight, ImageCache cache) &#123; final BitmapFactory.Options options = new BitmapFactory.Options(); ... BitmapFactory.decodeFile(filename, options); ... // If we&apos;re running on Honeycomb or newer, try to use inBitmap. if (Utils.hasHoneycomb()) &#123; addInBitmapOptions(options, cache); &#125; ... return BitmapFactory.decodeFile(filename, options);&#125; 下面代码显示了上述代码段中调用的addInBitmapOptions（）方法。12345678910111213141516171819202122232425262728293031323334353637383940414243444546private static void addInBitmapOptions(BitmapFactory.Options options, ImageCache cache) &#123; //inBitmap只适用于可变位图，因此强制解码器返回可变位图。 options.inMutable = true; if (cache != null) &#123; // 尝试找到用于inBitmap的位图。 Bitmap inBitmap = cache.getBitmapFromReusableSet(options); if (inBitmap != null) &#123; //如果找到合适的位图，请将其设置为值inBitmap。 options.inBitmap = inBitmap; &#125; &#125;&#125;//此方法遍历可重用的位图，查找一个用于inBitmap：protected Bitmap getBitmapFromReusableSet(BitmapFactory.Options options) &#123; Bitmap bitmap = null; if (mReusableBitmaps != null &amp;&amp; !mReusableBitmaps.isEmpty()) &#123; synchronized (mReusableBitmaps) &#123; final Iterator&lt;SoftReference&lt;Bitmap&gt;&gt; iterator = mReusableBitmaps.iterator(); Bitmap item; while (iterator.hasNext()) &#123; item = iterator.next().get(); if (null != item &amp;&amp; item.isMutable()) &#123; // 检查以查看该项目可用于inBitmap。 if (canUseForInBitmap(item, options)) &#123; bitmap = item; // 从可重复使用的设备中取出，因此无法再次使用。 iterator.remove(); break; &#125; &#125; else &#123; // 如果已清除引用，则从集合中删除。 iterator.remove(); &#125; &#125; &#125; &#125; return bitmap;&#125; 最后，此方法确定候选位图是否满足用于inBitmap的大小标准：123456789101112131415161718192021222324252627282930313233static boolean canUseForInBitmap( Bitmap candidate, BitmapFactory.Options targetOptions) &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; //从Android 4.4开始，我们可以重新使用新Bitmap小于可重复使用的 //Bitmap候选分配字节数。 int width = targetOptions.outWidth / targetOptions.inSampleSize; int height = targetOptions.outHeight / targetOptions.inSampleSize; int byteCount = width * height * getBytesPerPixel(candidate.getConfig()); return byteCount &lt;= candidate.getAllocationByteCount(); &#125; // 在早期版本中，维度必须完全匹配，并且inSampleSize必须为1 return candidate.getWidth() == targetOptions.outWidth &amp;&amp; candidate.getHeight() == targetOptions.outHeight &amp;&amp; targetOptions.inSampleSize == 1;&#125;/** *一个辅助函数，用于根据位图的配置返回位图的每个像素的字节使用情况。 */static int getBytesPerPixel(Config config) &#123; if (config == Config.ARGB_8888) &#123; return 4; &#125; else if (config == Config.RGB_565) &#123; return 2; &#125; else if (config == Config.ARGB_4444) &#123; return 2; &#125; else if (config == Config.ALPHA_8) &#123; return 1; &#125; return 1;&#125; 五 在UI中显示Bitmap下面将展示如何使用后台线程和位图缓存将多个位图加载到ViewPager和GridView组件中，同时处理并发和配置更改。 5.1 将位图加载到ViewPager实现中滑动视图图案是导航图库的详细视图的绝佳方式。 可以使用由PagerAdapter支持的ViewPager组件来实现此模式。 但是，更合适的后备适配器是子类FragmentStatePagerAdapter，它会在ViewPager中自动销毁和保存片段的状态，因为它们会在屏幕外消失，从而降低内存使用率。以下使用ImageView子级的ViewPager的实现。 主要活动包含ViewPager和适配器：1234567891011121314151617181920212223242526272829303132333435363738394041public class ImageDetailActivity extends FragmentActivity &#123; public static final String EXTRA_IMAGE = &quot;extra_image&quot;; private ImagePagerAdapter mAdapter; private ViewPager mPager; // 用于支持ViewPager适配器的静态数据集 public final static Integer[] imageResIds = new Integer[] &#123; R.drawable.sample_image_1, R.drawable.sample_image_2, R.drawable.sample_image_3, R.drawable.sample_image_4, R.drawable.sample_image_5, R.drawable.sample_image_6, R.drawable.sample_image_7, R.drawable.sample_image_8, R.drawable.sample_image_9&#125;; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.image_detail_pager); // 仅包含ViewPager mAdapter = new ImagePagerAdapter(getSupportFragmentManager(), imageResIds.length); mPager = (ViewPager) findViewById(R.id.pager); mPager.setAdapter(mAdapter); &#125; public static class ImagePagerAdapter extends FragmentStatePagerAdapter &#123; private final int mSize; public ImagePagerAdapter(FragmentManager fm, int size) &#123; super(fm); mSize = size; &#125; @Override public int getCount() &#123; return mSize; &#125; @Override public Fragment getItem(int position) &#123; return ImageDetailFragment.newInstance(position); &#125; &#125;&#125; 这是一个包含ImageView子元素的细节Fragment的实现,怎么可以改进？1234567891011121314151617181920212223242526272829303132333435363738public class ImageDetailFragment extends Fragment &#123; private static final String IMAGE_DATA_EXTRA = &quot;resId&quot;; private int mImageNum; private ImageView mImageView; static ImageDetailFragment newInstance(int imageNum) &#123; final ImageDetailFragment f = new ImageDetailFragment(); final Bundle args = new Bundle(); args.putInt(IMAGE_DATA_EXTRA, imageNum); f.setArguments(args); return f; &#125; // 空构造函数，根据Fragment docs所需 public ImageDetailFragment() &#123;&#125; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mImageNum = getArguments() != null ? getArguments().getInt(IMAGE_DATA_EXTRA) : -1; &#125; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; // image_detail_fragment.xml 只包含一个 ImageView final View v = inflater.inflate(R.layout.image_detail_fragment, container, false); mImageView = (ImageView) v.findViewById(R.id.imageView); return v; &#125; @Override public void onActivityCreated(Bundle savedInstanceState) &#123; super.onActivityCreated(savedInstanceState); final int resId = ImageDetailActivity.imageResIds[mImageNum]; mImageView.setImageResource(resId); // 将图像加载到ImageView中 &#125;&#125; 以上会有一个问题：从UI线程上的资源中读取图像，这可能导致应用程序挂起并被强制关闭。 使用处理位图关闭UI线程课程中描述的AsyncTask，可以直接将图像加载和处理移动到后台线程：12345678910111213141516171819202122232425public class ImageDetailActivity extends FragmentActivity &#123; ... public void loadBitmap(int resId, ImageView imageView) &#123; mImageView.setImageResource(R.drawable.image_placeholder); BitmapWorkerTask task = new BitmapWorkerTask(mImageView); task.execute(resId); &#125; ... // 包括BitmapWorkerTask类&#125;public class ImageDetailFragment extends Fragment &#123; ... @Override public void onActivityCreated(Bundle savedInstanceState) &#123; super.onActivityCreated(savedInstanceState); if (ImageDetailActivity.class.isInstance(getActivity())) &#123; final int resId = ImageDetailActivity.imageResIds[mImageNum]; // 调用ImageDetailActivity以在后台线程中加载Bitmap ((ImageDetailActivity) getActivity()).loadBitmap(resId, mImageView); &#125; &#125;&#125; 任何其他处理（例如调整大小或从网络获取图像）都可以在BitmapWorkerTask中进行，而不会影响主UI的响应性。 如果后台线程不仅仅是直接从磁盘加载映像，那么添加内存和/或磁盘缓存也是有益的， 以下是内存缓存的其他修改：12345678910111213141516171819202122232425public class ImageDetailActivity extends FragmentActivity &#123; ... private LruCache&lt;String, Bitmap&gt; mMemoryCache; @Override public void onCreate(Bundle savedInstanceState) &#123; ... // 根据“使用内存缓存”部分初始化LruCache &#125; public void loadBitmap(int resId, ImageView imageView) &#123; final String imageKey = String.valueOf(resId); final Bitmap bitmap = mMemoryCache.get(imageKey); if (bitmap != null) &#123; mImageView.setImageBitmap(bitmap); &#125; else &#123; mImageView.setImageResource(R.drawable.image_placeholder); BitmapWorkerTask task = new BitmapWorkerTask(mImageView); task.execute(resId); &#125; &#125; ... // 包括使用内存缓存部分更新的BitmapWorkerTask&#125; 将所有这些部分放在一起可以为您提供响应式ViewPager实现，同时将图像加载延迟降至最低，并且能够根据需要对图像进行尽可能多的背景处理。 5.2 将Bitmap加载到GridView中网格列表构建块对于显示图像数据集很有用，并且可以使用GridView组件实现，其中许多图像可以在任何时间在屏幕上显示，并且如果用户向上或向下滚动，还需要准备好更多图像。 实现此类控件时，必须确保UI保持流畅，内存使用仍然受到控制，并且正确处理并发（由于GridView回收其子视图的方式）。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public class ImageGridFragment extends Fragment implements AdapterView.OnItemClickListener &#123; private ImageAdapter mAdapter; //用于支持GridView适配器的静态数据集 public final static Integer[] imageResIds = new Integer[] &#123; R.drawable.sample_image_1, R.drawable.sample_image_2, R.drawable.sample_image_3, R.drawable.sample_image_4, R.drawable.sample_image_5, R.drawable.sample_image_6, R.drawable.sample_image_7, R.drawable.sample_image_8, R.drawable.sample_image_9&#125;; public ImageGridFragment() &#123;&#125; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mAdapter = new ImageAdapter(getActivity()); &#125; @Override public View onCreateView( LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; final View v = inflater.inflate(R.layout.image_grid_fragment, container, false); final GridView mGridView = (GridView) v.findViewById(R.id.gridView); mGridView.setAdapter(mAdapter); mGridView.setOnItemClickListener(this); return v; &#125; @Override public void onItemClick(AdapterView&lt;?&gt; parent, View v, int position, long id) &#123; final Intent i = new Intent(getActivity(), ImageDetailActivity.class); i.putExtra(ImageDetailActivity.EXTRA_IMAGE, position); startActivity(i); &#125; private class ImageAdapter extends BaseAdapter &#123; private final Context mContext; public ImageAdapter(Context context) &#123; super(); mContext = context; &#125; @Override public int getCount() &#123; return imageResIds.length; &#125; @Override public Object getItem(int position) &#123; return imageResIds[position]; &#125; @Override public long getItemId(int position) &#123; return position; &#125; @Override public View getView(int position, View convertView, ViewGroup container) &#123; ImageView imageView; if (convertView == null) &#123; // 如果它没有被回收，则初始化一些属性 imageView = new ImageView(mContext); imageView.setScaleType(ImageView.ScaleType.CENTER_CROP); imageView.setLayoutParams(new GridView.LayoutParams( LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT)); &#125; else &#123; imageView = (ImageView) convertView; &#125; imageView.setImageResource(imageResIds[position]); return imageView; &#125; &#125;&#125; 再一次，这个实现的问题是图像是在UI线程中设置的。 虽然这可能适用于小而简单的图像（由于系统资源加载和缓存），但如果需要进行任何其他处理，UI将停止运行。可以在此处实现前一节中的相同异步处理和缓存方法,这是解决方案：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class ImageGridFragment extends Fragment implements AdapterView.OnItemClickListener &#123; ... private class ImageAdapter extends BaseAdapter &#123; ... @Override public View getView(int position, View convertView, ViewGroup container) &#123; ... loadBitmap(imageResIds[position], imageView) return imageView; &#125; &#125; public void loadBitmap(int resId, ImageView imageView) &#123; if (cancelPotentialWork(resId, imageView)) &#123; final BitmapWorkerTask task = new BitmapWorkerTask(imageView); final AsyncDrawable asyncDrawable = new AsyncDrawable(getResources(), mPlaceHolderBitmap, task); imageView.setImageDrawable(asyncDrawable); task.execute(resId); &#125; &#125; static class AsyncDrawable extends BitmapDrawable &#123; private final WeakReference&lt;BitmapWorkerTask&gt; bitmapWorkerTaskReference; public AsyncDrawable(Resources res, Bitmap bitmap, BitmapWorkerTask bitmapWorkerTask) &#123; super(res, bitmap); bitmapWorkerTaskReference = new WeakReference&lt;BitmapWorkerTask&gt;(bitmapWorkerTask); &#125; public BitmapWorkerTask getBitmapWorkerTask() &#123; return bitmapWorkerTaskReference.get(); &#125; &#125; public static boolean cancelPotentialWork(int data, ImageView imageView) &#123; final BitmapWorkerTask bitmapWorkerTask = getBitmapWorkerTask(imageView); if (bitmapWorkerTask != null) &#123; final int bitmapData = bitmapWorkerTask.data; if (bitmapData != data) &#123; // 取消上一个任务 bitmapWorkerTask.cancel(true); &#125; else &#123; // 同样的工作已在进行中 return false; &#125; &#125; // 没有与ImageView关联的任务，或者已取消现有任务 return true; &#125; private static BitmapWorkerTask getBitmapWorkerTask(ImageView imageView) &#123; if (imageView != null) &#123; final Drawable drawable = imageView.getDrawable(); if (drawable instanceof AsyncDrawable) &#123; final AsyncDrawable asyncDrawable = (AsyncDrawable) drawable; return asyncDrawable.getBitmapWorkerTask(); &#125; &#125; return null; &#125; 注意：同样的代码也可以很容易地适用于ListView。","categories":[],"tags":[]},{"title":"初识OpenGL ES2.0","slug":"opengl-trangle","date":"2018-07-26T10:13:24.604Z","updated":"2018-07-26T10:13:24.552Z","comments":true,"path":"2018/07/26/opengl-trangle/","link":"","permalink":"http://yoursite.com/2018/07/26/opengl-trangle/","excerpt":"","text":"概述要在Android应用中使用OpenGL ES绘制图形就必须为它们创建一个视图容器,使用该容器这边就需要引入GLSurfaceView和GLSurfaceView.Renderer.GLSurfaceView是使用OpenGL和GLSurfaceView.Renderer绘制的图形的视图容器,用于控制在该视图中绘制内容.下面就介绍如何使用GLSurfaceView和GLSurfceView.Renderer完成简单的三角形绘制. 清单文件中声明OpenGL的使用如果我们的应用程序需要使用OpenGL ES2.0API,就需要在清单文件中进行声明123&lt;uses-feature android:glEsVersion=&quot;0x00020000&quot; android:required=&quot;true&quot; /&gt; 创建activity123456789public class OpenGlActivity extends AppCompatActivity &#123; private MyGlSurfaceView mGLView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mGLView=new MyGlSurfaceView(OpenGlActivity.this); setContentView(mGLView); &#125;&#125; 创建GLSurfaceView对象GLSurfaceView是一个专门的视图,在上面可以绘制OpenGL ES图形,本身并没有太大的作用,实际的对象绘制是在GLSurfaceView.Renderer中进行控制的.123456789101112131415public class MyGlSurfaceView extends GLSurfaceView implements View.OnTouchListener&#123; private final MyGLRender render; public MyGlSurfaceView(Context context) &#123; super(context); //设置openGL ES 版本 setEGLContextClientVersion(2); render=new MyGLRender(); //设置渲染器 setRenderer(render); //绘图数据发生更改时渲染视图 setRenderMode(GLSurfaceView.RENDERMODE_WHEN_DIRTY); &#125;&#125; 创建渲染器RendererRenderer控制在于其关联的SurfaceView上绘制内容,Renderer有三个方法供Android系统调用.(1) onSurfaceCreated() 调用一次,设置OpenGL ES环境.(2) onDrawFrame() 每次重绘进行时调用(3) onSurfaceChange() 视图几何图形发生改变时进行调用(eg:设备的屏幕方向发生改变)123456789101112131415161718public class MyRenerer implements GLSurfaceView.Renderer&#123; @Override public void onSurfaceCreated(GL10 gl10, EGLConfig eglConfig)&#123; //设置背景颜色 GLES20.glClearColor(0f,0f,0f,1f); &#125; @Override public void onSurfaceChanged(GL10 gl10, int i, int i1) &#123; //设置背景大小 GLES20.glViewport(0,0,i,i1); &#125; @Override public void onDrawFrame(GL10 gl10) &#123; //重绘背景颜色 GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT); &#125;&#125; 定义三角形OpenGL ES允许使用三维空间中的坐标定义绘制对象,所以在定义三角形之前,必须先定义其坐标.在OpenGL中，执行此操作的典型方法是为坐标定义浮点数的顶点数组。为了获得最大效率，可以将这些坐标写入ByteBuffer，并将其传递到OpenGL ES图形管道进行处理。1234567891011121314151617181920212223242526public class Triangle&#123; private FloatBuffer vertexBuffer; //数组中每个顶点的坐标 private static final int COOR_PER_VERTEX=3; //按逆时针顺序 private static final float triangleCoords[]=&#123; 0.0f,0.5f,0.0f,//顶点 -0.5f,-0.5f,0.0f,//左顶点 0.5f,-0.5f,0f//右顶点 &#125;; float color[]=&#123;0.0f,0.0f,0.0f,0.0f&#125;; public Trangle()&#123; //为三角形坐标初始化顶点字节缓冲区 //(坐标值的数量*每一个浮点数4个字节) ByteBuffer byteBuffer=ByteBuffer.allocateDirect( trangleCoords.length*4); //使用本机硬件的本机字节顺序 byteBuffer.order(ByteOrder.nativeOrder()); //从ByteBuffer创建一个浮点缓冲区 vertexBuffer = byteBuffer.asFloatBuffer(); //将坐标添加到FloatBuffer vertexBuffer.put(triangleCoords); //设置缓冲区读取第一个坐标 vertexBuffer.position(0); &#125;&#125; 初始化三角形在进行绘图之前,必须初始化并加载计划绘制的形状,除非程序中使用的形状的结构（原始坐标）在执行过程中发生变化，否则应在渲染器的onSurfaceCreated（）方法中初始化它们，以获得内存和处理效率12345678910public class MyGLRender implements GLSurfaceView.Renderer&#123; private Triangle mTriangle; @Override public void onSurfaceCreated(GL10 gl10, EGLConfig eglConfig)&#123; //设置背景颜色 GLES20.glClearColor(0f,0f,0f,1f); mTriangle=new Triangle(); &#125; &#125; 绘制三角形首先需要定义如下内容:(1) Vertex Shader -顶点着色器,用于渲染形状顶点的OpenGL ES图形代码。(2)Fragment Shader -OpenGL ES代码，用于渲染具有颜色或纹理的形状的面。(3) Program -一个OpenGL ES对象，包含要用于绘制一个或多个形状的着色器。我们需要至少一个顶点着色器来绘制形状，并使用一个片段着色器为该形状着色。必须编译这些着色器，然后将其添加到OpenGL ES程序中，然后使用该程序绘制形状。以下是如何定义可用于在Triangle类中绘制形状的基本着色器的示例：1234567891011121314151617public class Triangle&#123; private final String vertexShaderCode = // This matrix member variable provides a hook to manipulate // the coordinates of the objects that use this vertex shader &quot;uniform mat4 uMVPMatrix;&quot; + &quot;attribute vec4 vPosition;&quot; + &quot;void main() &#123;&quot; + &quot; gl_Position = uMVPMatrix * vPosition;&quot; + &quot;&#125;&quot;; private final String fragmentShaderCode = &quot;precision mediump float;&quot; + &quot;uniform vec4 vColor;&quot; + &quot;void main() &#123;&quot; + &quot; gl_FragColor = vColor;&quot; + &quot;&#125;&quot;;&#125; 着色器包含OpenGL着色语言（GLSL）代码，必须在OpenGL ES环境中使用它之前进行编译。要编译此代码，要Renderer类中创建以下该方法：123456789101112public static int loadShader(int type, String shaderCode)&#123; // create a vertex shader type (GLES20.GL_VERTEX_SHADER) // or a fragment shader type (GLES20.GL_FRAGMENT_SHADER) int shader = GLES20.glCreateShader(type); // add the source code to the shader and compile it GLES20.glShaderSource(shader, shaderCode); GLES20.glCompileShader(shader); return shader; &#125; 创建Draw()方法绘制形状1234567891011121314151617181920212223242526272829private int mPositionHandle; private int mColorHandle; private static final int COORDS_PER_VERTEX = 3; private final int vertexCount = triangleCoords.length /COORDS_PER_VERTEX; private final int vertexStride = COORDS_PER_VERTEX * 4; public void draw(float[] mvpMatrix) &#123; //将程序添加到OpenGL ES环境 GLES20.glUseProgram(mProgram); //获取顶点着色器位置成员的句柄 mPositionHandle=GLES20.glGetAttribLocation(mProgram, &quot;vPosition&quot;); //启用三角形顶点的句柄 GLES20.glEnableVertexAttribArray(mPositionHandle); //准备三角坐标数据 GLES20.glVertexAttribPointer(mPositionHandle,COOR_PER_VERTEX, GLES20.GL_FLOAT,false,vertexStride,vertexBuffer); //获取片段着色器Color成员的句柄 mColorHandle=GLES20.glGetUniformLocation(mProgram,&quot;vColor&quot;); //设置绘制三角形的颜色 GLES20.glUniform4fv(mColorHandle,1,color,0); //获得形状的变换矩阵的handle mMVPMatrixHandle=GLES20.glGetUniformLocation(mProgram,&quot;uMVPMatrix&quot;); //把变换矩阵传给着色器 GLES20.glUniformMatrix4fv(mMVPMatrixHandle,1,false,mvpMatrix,0); //绘制三角形 GLES20.glDrawArrays(GLES20.GL_TRIANGLES,0,vertexCount); //禁用顶点数组 GLES20.glEnableVertexAttribArray(mPositionHandle); &#125; 最后在Renderer的onDrawFrame()方法中调用draw()方法.要想的三角形就出现啦!小白一个后续更新!","categories":[],"tags":[]},{"title":"浅谈Android MediaPlayer","slug":"mediaplayer","date":"2018-07-26T10:06:19.576Z","updated":"2018-07-26T10:06:19.536Z","comments":true,"path":"2018/07/26/mediaplayer/","link":"","permalink":"http://yoursite.com/2018/07/26/mediaplayer/","excerpt":"","text":"前言MediaPlayer是Android中多媒体框架中一个重要的组件,我们通过它可以控制在线或者本地音视频的播放过程. MeidaPlayer具体方法介绍1.void setDataSource(String url)通过一个具体的路径来设置MediaPlayer的数据源，url可以是本地的一个路径，也可以是一个网络路径. 2.void setDataSource(Context context, Uri uri )通过给定的Uri来设置MediaPlayer的数据源，这里的Uri可以是网络路径或是一个ContentProvider的Uri. 3.void setDataSource(MediaDataSource dataSource) 通过提供的MediaDataSource来设置数据源 4.void setDataSource(FileDescriptor fd) 通过文件描述符FileDescriptor来设置数据源 5.getCurrentPosition()获取当前播放位置 6.getDuration()得到文件时间 7.boolean isLooping()是否循环播放 8.boolean isPlaying()是否正在播放 9.void pause()暂停 10.void stop()停止 11.void start()播放 12.void prepare()同步装载流媒体文件 13.void prepareAsync()异步装载流媒体文件 14.void reset()重置MeidaPlayer至未初始的状态 15.void release()回收流媒体资源 16.void seekTo(int msec)指定播放位置(毫秒计算) 17.void setAudioStreamType(int streamtype) 指定流媒体类型 18.void setLooping(boolean looping) 设置是否单曲循环 19.setOnBufferingUpdateListener(MediaPlayer.OnBufferingUpdateListener listener) 网络流媒体的缓冲变化时回调 ** 20.setOnCompletionListener(MediaPlayer.OnCompletionListener listener) 网络流媒体播放结束时回调 21.setOnErrorListener(MediaPlayer.OnErrorListener listener) 发生错误时回调 ** 22.setOnPreparedListener(MediaPlayer.OnPreparedListener listener)：当装载流媒体完毕的时候回调。 注意的点1.在使用start()播放流媒体之前,需要装载流媒体资源,建议最好使用prepareAsync()异步装载的方式装载流媒体资源.这是因为流媒体资源的装载会消耗系统资源,在一些硬件设备不理想的情况下,可能会造成界面的卡顿.为了避免还没有装载完成就调用start()而报错的问题，需要绑定MediaPlayer.setOnPreparedListener()事件，它将在异步装载完成之后回调.12345678910111213141516mediaPlayer.reset();try &#123; mediaPlayer.setDataSource(url); mediaPlayer.prepareAsync(); mediaPlayer.setOnPreparedListener(onPreparedListener);&#125;catch (IOException e) &#123; e.printStackTrace();&#125;public MediaPlayer.OnPreparedListener onPreparedListener = new MediaPlayer.OnPreparedListener() &#123; @Override public void onPrepared(MediaPlayer mp) &#123; //开始播放 mp.start(); &#125;&#125;; 2.getCurrentPosition()以及getDuration()方法调用事件,如果媒体资源未start()之前就调用这两个方法,则会触发MeidaPlayer.setOnErrorListener()事件,在onError()方法中,我们一般是执行next()方法,所以就会导致切歌的现象. 3.播放完毕后的操作,这里就有另一个监听事件了MediaPlayer.setOnCompletionListener(),资源播放完毕一般的处理和onError()一致,都是执行next()方法. 4.MeidaPlayer的回收,MediaPlayer是很消耗系统资源的，所以在使用完MediaPlayer，不要等待系统自动回收，最好是主动回收资源。12345if (mediaPlayer != null) &#123; mediaPlayer.reset(); mediaPlayer.release(); mediaPlayer = null;&#125;","categories":[],"tags":[]}]}