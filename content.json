{"meta":{"title":"Sunny.SLX的个人博.","subtitle":null,"description":null,"author":"Sunny.SLX","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"初识OpenGL ES2.0","slug":"opengl-trangle","date":"2018-07-26T10:13:24.604Z","updated":"2018-07-26T10:13:24.552Z","comments":true,"path":"2018/07/26/opengl-trangle/","link":"","permalink":"http://yoursite.com/2018/07/26/opengl-trangle/","excerpt":"","text":"概述要在Android应用中使用OpenGL ES绘制图形就必须为它们创建一个视图容器,使用该容器这边就需要引入GLSurfaceView和GLSurfaceView.Renderer.GLSurfaceView是使用OpenGL和GLSurfaceView.Renderer绘制的图形的视图容器,用于控制在该视图中绘制内容.下面就介绍如何使用GLSurfaceView和GLSurfceView.Renderer完成简单的三角形绘制. 清单文件中声明OpenGL的使用如果我们的应用程序需要使用OpenGL ES2.0API,就需要在清单文件中进行声明123&lt;uses-feature android:glEsVersion=&quot;0x00020000&quot; android:required=&quot;true&quot; /&gt; 创建activity123456789public class OpenGlActivity extends AppCompatActivity &#123; private MyGlSurfaceView mGLView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mGLView=new MyGlSurfaceView(OpenGlActivity.this); setContentView(mGLView); &#125;&#125; 创建GLSurfaceView对象GLSurfaceView是一个专门的视图,在上面可以绘制OpenGL ES图形,本身并没有太大的作用,实际的对象绘制是在GLSurfaceView.Renderer中进行控制的.123456789101112131415public class MyGlSurfaceView extends GLSurfaceView implements View.OnTouchListener&#123; private final MyGLRender render; public MyGlSurfaceView(Context context) &#123; super(context); //设置openGL ES 版本 setEGLContextClientVersion(2); render=new MyGLRender(); //设置渲染器 setRenderer(render); //绘图数据发生更改时渲染视图 setRenderMode(GLSurfaceView.RENDERMODE_WHEN_DIRTY); &#125;&#125; 创建渲染器RendererRenderer控制在于其关联的SurfaceView上绘制内容,Renderer有三个方法供Android系统调用.(1) onSurfaceCreated() 调用一次,设置OpenGL ES环境.(2) onDrawFrame() 每次重绘进行时调用(3) onSurfaceChange() 视图几何图形发生改变时进行调用(eg:设备的屏幕方向发生改变)123456789101112131415161718public class MyRenerer implements GLSurfaceView.Renderer&#123; @Override public void onSurfaceCreated(GL10 gl10, EGLConfig eglConfig)&#123; //设置背景颜色 GLES20.glClearColor(0f,0f,0f,1f); &#125; @Override public void onSurfaceChanged(GL10 gl10, int i, int i1) &#123; //设置背景大小 GLES20.glViewport(0,0,i,i1); &#125; @Override public void onDrawFrame(GL10 gl10) &#123; //重绘背景颜色 GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT); &#125;&#125; 定义三角形OpenGL ES允许使用三维空间中的坐标定义绘制对象,所以在定义三角形之前,必须先定义其坐标.在OpenGL中，执行此操作的典型方法是为坐标定义浮点数的顶点数组。为了获得最大效率，可以将这些坐标写入ByteBuffer，并将其传递到OpenGL ES图形管道进行处理。1234567891011121314151617181920212223242526public class Triangle&#123; private FloatBuffer vertexBuffer; //数组中每个顶点的坐标 private static final int COOR_PER_VERTEX=3; //按逆时针顺序 private static final float triangleCoords[]=&#123; 0.0f,0.5f,0.0f,//顶点 -0.5f,-0.5f,0.0f,//左顶点 0.5f,-0.5f,0f//右顶点 &#125;; float color[]=&#123;0.0f,0.0f,0.0f,0.0f&#125;; public Trangle()&#123; //为三角形坐标初始化顶点字节缓冲区 //(坐标值的数量*每一个浮点数4个字节) ByteBuffer byteBuffer=ByteBuffer.allocateDirect( trangleCoords.length*4); //使用本机硬件的本机字节顺序 byteBuffer.order(ByteOrder.nativeOrder()); //从ByteBuffer创建一个浮点缓冲区 vertexBuffer = byteBuffer.asFloatBuffer(); //将坐标添加到FloatBuffer vertexBuffer.put(triangleCoords); //设置缓冲区读取第一个坐标 vertexBuffer.position(0); &#125;&#125; 初始化三角形在进行绘图之前,必须初始化并加载计划绘制的形状,除非程序中使用的形状的结构（原始坐标）在执行过程中发生变化，否则应在渲染器的onSurfaceCreated（）方法中初始化它们，以获得内存和处理效率12345678910public class MyGLRender implements GLSurfaceView.Renderer&#123; private Triangle mTriangle; @Override public void onSurfaceCreated(GL10 gl10, EGLConfig eglConfig)&#123; //设置背景颜色 GLES20.glClearColor(0f,0f,0f,1f); mTriangle=new Triangle(); &#125; &#125; 绘制三角形首先需要定义如下内容:(1) Vertex Shader -顶点着色器,用于渲染形状顶点的OpenGL ES图形代码。(2)Fragment Shader -OpenGL ES代码，用于渲染具有颜色或纹理的形状的面。(3) Program -一个OpenGL ES对象，包含要用于绘制一个或多个形状的着色器。我们需要至少一个顶点着色器来绘制形状，并使用一个片段着色器为该形状着色。必须编译这些着色器，然后将其添加到OpenGL ES程序中，然后使用该程序绘制形状。以下是如何定义可用于在Triangle类中绘制形状的基本着色器的示例：1234567891011121314151617public class Triangle&#123; private final String vertexShaderCode = // This matrix member variable provides a hook to manipulate // the coordinates of the objects that use this vertex shader &quot;uniform mat4 uMVPMatrix;&quot; + &quot;attribute vec4 vPosition;&quot; + &quot;void main() &#123;&quot; + &quot; gl_Position = uMVPMatrix * vPosition;&quot; + &quot;&#125;&quot;; private final String fragmentShaderCode = &quot;precision mediump float;&quot; + &quot;uniform vec4 vColor;&quot; + &quot;void main() &#123;&quot; + &quot; gl_FragColor = vColor;&quot; + &quot;&#125;&quot;;&#125; 着色器包含OpenGL着色语言（GLSL）代码，必须在OpenGL ES环境中使用它之前进行编译。要编译此代码，要Renderer类中创建以下该方法：123456789101112public static int loadShader(int type, String shaderCode)&#123; // create a vertex shader type (GLES20.GL_VERTEX_SHADER) // or a fragment shader type (GLES20.GL_FRAGMENT_SHADER) int shader = GLES20.glCreateShader(type); // add the source code to the shader and compile it GLES20.glShaderSource(shader, shaderCode); GLES20.glCompileShader(shader); return shader; &#125; 创建Draw()方法绘制形状1234567891011121314151617181920212223242526272829private int mPositionHandle; private int mColorHandle; private static final int COORDS_PER_VERTEX = 3; private final int vertexCount = triangleCoords.length /COORDS_PER_VERTEX; private final int vertexStride = COORDS_PER_VERTEX * 4; public void draw(float[] mvpMatrix) &#123; //将程序添加到OpenGL ES环境 GLES20.glUseProgram(mProgram); //获取顶点着色器位置成员的句柄 mPositionHandle=GLES20.glGetAttribLocation(mProgram, &quot;vPosition&quot;); //启用三角形顶点的句柄 GLES20.glEnableVertexAttribArray(mPositionHandle); //准备三角坐标数据 GLES20.glVertexAttribPointer(mPositionHandle,COOR_PER_VERTEX, GLES20.GL_FLOAT,false,vertexStride,vertexBuffer); //获取片段着色器Color成员的句柄 mColorHandle=GLES20.glGetUniformLocation(mProgram,&quot;vColor&quot;); //设置绘制三角形的颜色 GLES20.glUniform4fv(mColorHandle,1,color,0); //获得形状的变换矩阵的handle mMVPMatrixHandle=GLES20.glGetUniformLocation(mProgram,&quot;uMVPMatrix&quot;); //把变换矩阵传给着色器 GLES20.glUniformMatrix4fv(mMVPMatrixHandle,1,false,mvpMatrix,0); //绘制三角形 GLES20.glDrawArrays(GLES20.GL_TRIANGLES,0,vertexCount); //禁用顶点数组 GLES20.glEnableVertexAttribArray(mPositionHandle); &#125; 最后在Renderer的onDrawFrame()方法中调用draw()方法.要想的三角形就出现啦!小白一个后续更新!","categories":[],"tags":[]},{"title":"浅谈Android MediaPlayer","slug":"mediaplayer","date":"2018-07-26T10:06:19.576Z","updated":"2018-07-26T10:06:19.536Z","comments":true,"path":"2018/07/26/mediaplayer/","link":"","permalink":"http://yoursite.com/2018/07/26/mediaplayer/","excerpt":"","text":"前言MediaPlayer是Android中多媒体框架中一个重要的组件,我们通过它可以控制在线或者本地音视频的播放过程. MeidaPlayer具体方法介绍1.void setDataSource(String url)通过一个具体的路径来设置MediaPlayer的数据源，url可以是本地的一个路径，也可以是一个网络路径. 2.void setDataSource(Context context, Uri uri )通过给定的Uri来设置MediaPlayer的数据源，这里的Uri可以是网络路径或是一个ContentProvider的Uri. 3.void setDataSource(MediaDataSource dataSource) 通过提供的MediaDataSource来设置数据源 4.void setDataSource(FileDescriptor fd) 通过文件描述符FileDescriptor来设置数据源 5.getCurrentPosition()获取当前播放位置 6.getDuration()得到文件时间 7.boolean isLooping()是否循环播放 8.boolean isPlaying()是否正在播放 9.void pause()暂停 10.void stop()停止 11.void start()播放 12.void prepare()同步装载流媒体文件 13.void prepareAsync()异步装载流媒体文件 14.void reset()重置MeidaPlayer至未初始的状态 15.void release()回收流媒体资源 16.void seekTo(int msec)指定播放位置(毫秒计算) 17.void setAudioStreamType(int streamtype) 指定流媒体类型 18.void setLooping(boolean looping) 设置是否单曲循环 19.setOnBufferingUpdateListener(MediaPlayer.OnBufferingUpdateListener listener) 网络流媒体的缓冲变化时回调 ** 20.setOnCompletionListener(MediaPlayer.OnCompletionListener listener) 网络流媒体播放结束时回调 21.setOnErrorListener(MediaPlayer.OnErrorListener listener) 发生错误时回调 ** 22.setOnPreparedListener(MediaPlayer.OnPreparedListener listener)：当装载流媒体完毕的时候回调。 注意的点1.在使用start()播放流媒体之前,需要装载流媒体资源,建议最好使用prepareAsync()异步装载的方式装载流媒体资源.这是因为流媒体资源的装载会消耗系统资源,在一些硬件设备不理想的情况下,可能会造成界面的卡顿.为了避免还没有装载完成就调用start()而报错的问题，需要绑定MediaPlayer.setOnPreparedListener()事件，它将在异步装载完成之后回调.12345678910111213141516mediaPlayer.reset();try &#123; mediaPlayer.setDataSource(url); mediaPlayer.prepareAsync(); mediaPlayer.setOnPreparedListener(onPreparedListener);&#125;catch (IOException e) &#123; e.printStackTrace();&#125;public MediaPlayer.OnPreparedListener onPreparedListener = new MediaPlayer.OnPreparedListener() &#123; @Override public void onPrepared(MediaPlayer mp) &#123; //开始播放 mp.start(); &#125;&#125;; 2.getCurrentPosition()以及getDuration()方法调用事件,如果媒体资源未start()之前就调用这两个方法,则会触发MeidaPlayer.setOnErrorListener()事件,在onError()方法中,我们一般是执行next()方法,所以就会导致切歌的现象. 3.播放完毕后的操作,这里就有另一个监听事件了MediaPlayer.setOnCompletionListener(),资源播放完毕一般的处理和onError()一致,都是执行next()方法. 4.MeidaPlayer的回收,MediaPlayer是很消耗系统资源的，所以在使用完MediaPlayer，不要等待系统自动回收，最好是主动回收资源。12345if (mediaPlayer != null) &#123; mediaPlayer.reset(); mediaPlayer.release(); mediaPlayer = null;&#125;","categories":[],"tags":[]},{"title":"Android 自定义View","slug":"view-md","date":"2018-07-23T10:37:30.228Z","updated":"2018-07-23T10:37:30.176Z","comments":true,"path":"2018/07/23/view-md/","link":"","permalink":"http://yoursite.com/2018/07/23/view-md/","excerpt":"","text":"前言Android官方文档对View的解释是这样的:表示用户界面组件的基本构建块。视图占据屏幕上的矩形区域，负责绘图和事件处理。以下将自定义View基础、自定义View绘制流程、事件分发机制这三个方面来介绍Android自定义View。一.自定义View基础1.1.坐标系屏幕坐标系与数学坐标系的差异 1.1.1.屏幕坐标系 1.1.1.view的坐标系注意：View的坐标系都是相对于父控件而言。 1.2.颜色三原色 1.3.分类根据用途来分，一般将自定义分为两种：即自定义控件和自定义布局. 1.4.自定义属性自定义属性步骤 二.自定义view绘制流程2.1.绘制流程 2.2.相关函数介绍2.2.1.构造函数一个参的构造，一般在java代码中直接new一个View时调用。 两个参的构造，一般在Layout文件中使用的时候调用，关于它的所有属性（包括自定义属性）都会通过attrs传递进来。 三个参数的构造，第三个参数是默认的Style，这里的默认的Style是指它在当前Application或Activity所用的Theme中的默认Style。四个参数的构造，第四个参数是指向一个style的ID，但是是在defStyleAttr为0,或者defStyle不为0，但theme没有为defStyleAttr属性赋值时起作用。 2.2.2.测量view的大小函数-onMeasure()作用：测量View的大小，并从widthMeasureSpec 和 heightMeasureSpec中取出宽高的相关数据，它们其实不是宽和高， 而是由宽、高和各自方向上对应的测量模式来合成的一个值。测量模式:三种测量模式,通过MeasureSpec.getMode()得到测量模式， Measure.getSize()得到测量数值。 2.2.3.确定view的大小函数-onSizeChanged()作用：确定View大小,在视图大小发生改变时调用,它有四个参数，分别为宽度，高度，上一次宽度，上一次高度。 2.2.4.确定子view的布局-onLayout()作用：它用于确定子View的位置，在自定义ViewGroup中会用到，他调用的是子View的layout函数。它有四个参数如下： 2.2.5.绘制view的函数-onDraw()作用：绘制内容，使用canvas进行绘图. 三.事件分发机制为什么要有事件分发机制？Android View是有可能重叠在一起的，当我们点击的地方有多个View响应时，这个点击事件应该分发给谁？为了解决这一部分就有了事件分发机制。 3.1.事件分发核心函数以上三个方法都有一个boolean类型的返回值，通过返回true或者false来控制事件的流程. 3.2.事件分发流程责任链模式，即如果自己能处理就拦截下来自己处理，如果不能处理或者不确定就交给责任链中的下一个对象。如下图： 3.2.1.事件分发机制流程详解事件传递顺序:注意：事件传递过程先执行分发,再执行拦截,事件传递返回 true,表示事件被拦截，交给自己的onTouchEvent处理；false,表示不拦截，向下传递。事件处理顺序:注意：事件的处理都要进过onTouchEvent，事件处理返回true，表示事件自己处理，false，表示向上传递。 3.2.2.事件分发机制流程概括 (1)事件如果被消费，就意味着事件传递消息被终止。 (2)如果事件一直没有被消费就会传递给activity，如果activity也不需要就会被抛弃。 (3)判断事件是否被消费是根据返回值，并不是根据你是否使用了该事件。 Android 事件分发，一般可以理解为：&emsp; &emsp;(a)ViewGroup对点击事件的分发机制。&emsp; &emsp;(b)View对点击事件的分发机制。 3.3.MotionEvent对象根据面向对象的思想，事件被封装成MotionEvent对象。对于单指触控来说，一次简单的交互流程是： 3.4.ViewGroup的事件分发注意：ViewGroup的事件分发不仅要考虑自身，还要考虑子View.ViewGroup的分发流程: 3.4.1.子view存在重合点时的处理情况一： &emsp; &emsp;只有View1可以点击时，该点击事件分配给View1情况二： &emsp; &emsp;只有View2可以点击时，该点击事件分配给View2情况三： &emsp; &emsp;View1、View2均可点击时，该点击事件分配给View2,如果View2将事件消费掉了，则View1将接收不到. 3.4.2.view的可点击情况分类: &emsp; &emsp;onClick &emsp; &emsp;onLongClick &emsp; &emsp;onContextClick &emsp; &emsp;android:clickable=“true” &emsp; &emsp;button ,ImageButton,CheckBox默认是可点击的。 3.5.view的事件分发流程 3.5.总结","categories":[],"tags":[]}]}